/*!
* \file   TFEL/Material/MCBigoniMiniKHD.hxx
* \brief  this file implements the MCBigoniMiniKHD Behaviour.
*         File generated by tfel version 3.4.0
* \author Simon Raude
* \date   08 / 10 / 2022
 */

#ifndef LIB_TFELMATERIAL_MCBIGONIMINIKHD_HXX
#define LIB_TFELMATERIAL_MCBIGONIMINIKHD_HXX

#include<string>
#include<iostream>
#include<limits>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/Metaprogramming/StaticAssert.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Material/MaterialException.hxx"
#include"TFEL/Material/MechanicalBehaviour.hxx"
#include"TFEL/Material/MechanicalBehaviourTraits.hxx"
#include"TFEL/Material/OutOfBoundsPolicy.hxx"
#include"TFEL/Material/BoundsCheck.hxx"
#include"TFEL/Material/IsotropicPlasticity.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/Hosford1972YieldCriterion.hxx"
#include"TFEL/Material/MCBigoniMiniKHDBehaviourData.hxx"
#include"TFEL/Material/MCBigoniMiniKHDIntegrationData.hxx"

#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Math/Vector/TinyVectorFromTinyVectorView.hxx"
#include"TFEL/Math/Vector/TinyVectorFromTinyVectorViewIO.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyVectorView.hxx"
#include "TFEL/Math/Stensor/StensorFromTinyMatrixRowView.hxx"
#include "TFEL/Math/Stensor/StensorFromTinyMatrixRowView2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2FromTinyMatrixView.hxx"

#include"TFEL/Math/ST2toST2/ST2toST2FromTinyMatrixView2.hxx"

#include"TFEL/Math/Stensor/StensorFromTinyMatrixColumnView.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixRowView.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixColumnView2.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixRowView2.hxx"
#include"TFEL/Math/Vector/TinyVectorOfStensorFromTinyVectorView.hxx"
#include"TFEL/Math/Vector/TinyVectorOfStensorFromTinyVectorViewIO.hxx"
#line 128 "MCBigoniMiniKHD.mfront"
#include"TFEL/Material/Lame.hxx"

#include"MFront/Aster/Aster.hxx"

namespace tfel{

namespace material{

struct MCBigoniMiniKHDParametersInitializer
{
static MCBigoniMiniKHDParametersInitializer&
get();

double theta;
double epsilon;
double minimal_time_step_scaling_factor;
double maximal_time_step_scaling_factor;
double numerical_jacobian_epsilon;
unsigned short iterMax;

void set(const char* const,const double);

void set(const char* const,const unsigned short);

/*!
 * \brief convert a string to double
 * \param[in] p : parameter
 * \param[in] v : value
 */
static double getDouble(const std::string&,const std::string&);
/*!
 * \brief convert a string to unsigned short
 * \param[in] p : parameter
 * \param[in] v : value
 */
static unsigned short getUnsignedShort(const std::string&,const std::string&);
private :

MCBigoniMiniKHDParametersInitializer();

MCBigoniMiniKHDParametersInitializer(const MCBigoniMiniKHDParametersInitializer&);

MCBigoniMiniKHDParametersInitializer&
operator=(const MCBigoniMiniKHDParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(MCBigoniMiniKHDParametersInitializer&,const char* const);
};

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis,typename Type,bool use_qt>
class MCBigoniMiniKHD;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
 operator <<(std::ostream&,const MCBigoniMiniKHD<hypothesis,Type,false>&);

/*!
* \class MCBigoniMiniKHD
* \brief This class implements the MCBigoniMiniKHD behaviour.
* \param hypothesis, modelling hypothesis.
* \param Type, numerical type.
* \author Simon Raude
* \date   08 / 10 / 2022
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class MCBigoniMiniKHD<hypothesis,Type,false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>,
public MCBigoniMiniKHDBehaviourData<hypothesis,Type,false>,
public MCBigoniMiniKHDIntegrationData<hypothesis,Type,false>
{

static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

TFEL_STATIC_ASSERT(N==1||N==2||N==3);
TFEL_STATIC_ASSERT(tfel::typetraits::IsFundamentalNumericType<Type>::cond);
TFEL_STATIC_ASSERT(tfel::typetraits::IsReal<Type>::cond);

friend std::ostream& operator<< <>(std::ostream&,const MCBigoniMiniKHD&);

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N,Type,false>;
using real                = typename Types::real;
using time                = typename Types::time;
using length              = typename Types::length;
using frequency           = typename Types::frequency;
using stress              = typename Types::stress;
using strain              = typename Types::strain;
using strainrate          = typename Types::strainrate;
using stressrate          = typename Types::stressrate;
using temperature         = typename Types::temperature;
using thermalexpansion    = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity         = typename Types::massdensity;
using energydensity         = typename Types::energydensity;
using TVector             = typename Types::TVector;
using Stensor             = typename Types::Stensor;
using Stensor4            = typename Types::Stensor4;
using FrequencyStensor    = typename Types::FrequencyStensor;
using ForceTVector        = typename Types::ForceTVector;
using StressStensor       = typename Types::StressStensor;
using StressRateStensor   = typename Types::StressRateStensor;
using DisplacementTVector = typename Types::DisplacementTVector;
using StrainStensor       = typename Types::StrainStensor;
using StrainRateStensor   = typename Types::StrainRateStensor;
using StiffnessTensor     = typename Types::StiffnessTensor;
using Tensor              = typename Types::Tensor;
using FrequencyTensor     = typename Types::FrequencyTensor;
using StressTensor        = typename Types::StressTensor;
using ThermalExpansionCoefficientTensor = typename Types::ThermalExpansionCoefficientTensor;
using DeformationGradientTensor         = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor     = typename Types::DeformationGradientRateTensor;
using TemperatureGradient = typename Types::TemperatureGradient;
using HeatFlux = typename Types::HeatFlux;
using TangentOperator   = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<real>;

public :

typedef MCBigoniMiniKHDBehaviourData<hypothesis,Type,false> BehaviourData;
typedef MCBigoniMiniKHDIntegrationData<hypothesis,Type,false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :



typename tfel::math::StensorFromTinyVectorView<N,2+2*StensorSize,0,real>::type deel;
#line 91 "MCBigoniMiniKHD.mfront"
typename tfel::math::StensorFromTinyVectorView<N,2+2*StensorSize,StensorSize,real>::type depl;
#line 92 "MCBigoniMiniKHD.mfront"
real& dlam;
#line 93 "MCBigoniMiniKHD.mfront"
real& dalp;

#line 66 "MCBigoniMiniKHD.mfront"
tfel::math::tvector<2, bool > b;
#line 67 "MCBigoniMiniKHD.mfront"
real local_zero_tolerance;
#line 68 "MCBigoniMiniKHD.mfront"
real pi;
#line 69 "MCBigoniMiniKHD.mfront"
real phir;
#line 70 "MCBigoniMiniKHD.mfront"
real psir;
#line 71 "MCBigoniMiniKHD.mfront"
real thetaFm;
#line 72 "MCBigoniMiniKHD.mfront"
real thetaGm;
#line 73 "MCBigoniMiniKHD.mfront"
real KFm;
#line 74 "MCBigoniMiniKHD.mfront"
real KGm;
#line 75 "MCBigoniMiniKHD.mfront"
stress aG;
#line 76 "MCBigoniMiniKHD.mfront"
real bK;
#line 77 "MCBigoniMiniKHD.mfront"
real bMu;
#line 78 "MCBigoniMiniKHD.mfront"
real alpc;
#line 79 "MCBigoniMiniKHD.mfront"
real rD;
#line 80 "MCBigoniMiniKHD.mfront"
Stensor4 Ce;
#line 81 "MCBigoniMiniKHD.mfront"
Stensor4 Ckin;
#line 82 "MCBigoniMiniKHD.mfront"
stress lambda;
#line 83 "MCBigoniMiniKHD.mfront"
stress mu;
#line 84 "MCBigoniMiniKHD.mfront"
stress ks;
#line 85 "MCBigoniMiniKHD.mfront"
Stensor nGtmp;

real theta;
real epsilon;
real minimal_time_step_scaling_factor;
real maximal_time_step_scaling_factor;
real numerical_jacobian_epsilon;
ushort iterMax;

//! Tangent operator;
TangentOperator Dt;
//! alias to the tangent operator;
TangentOperator& dsig_ddeto;
// updating material properties, in mandatory
void updateMaterialPropertiesDependantOnStateVariables(){
using namespace std;
using namespace tfel::math;
using std::vector;
}

// Jacobian
tfel::math::tmatrix<2+2*StensorSize,2+2*StensorSize,real> jacobian;
// zeros
tfel::math::tvector<2+2*StensorSize,real> zeros;

// previous zeros
tfel::math::tvector<2+2*StensorSize,real> zeros_1;

// function
tfel::math::tvector<2+2*StensorSize,real> fzeros;

// number of iterations
unsigned int iter = 0u;

void computeNumericalJacobian(tfel::math::tmatrix<2+2*StensorSize,2+2*StensorSize,real>& njacobian)
{
using namespace std;
using namespace tfel::math;
tvector<2+2*StensorSize,real> tzeros(this->zeros);
tvector<2+2*StensorSize,real> tfzeros(this->fzeros);
tmatrix<2+2*StensorSize,2+2*StensorSize,real> tjacobian(this->jacobian);
for(unsigned short idx = 0; idx!= 2+2*StensorSize;++idx){
this->zeros(idx) -= this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->zeros = tzeros;
tvector<2+2*StensorSize,real> tfzeros2(this->fzeros);
this->zeros(idx) += this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->fzeros = (this->fzeros-tfzeros2)/(2*(this->numerical_jacobian_epsilon));
for(unsigned short idx2 = 0; idx2!= 2+2*StensorSize;++idx2){
njacobian(idx2,idx) = this->fzeros(idx2);
}
this->zeros    = tzeros;
this->fzeros   = tfzeros;
}
if(&njacobian!=&(this->jacobian)){
this->jacobian = tjacobian;
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+2*StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+2*StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+2*StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+2*StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_epl)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+2*StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+2*StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
for(unsigned short idx2=StensorSize;idx2!=2*StensorSize;++idx2){
partial_jacobian_epl(idx2,idx)=vect_e(idx2);
}
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+2*StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_epl,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_lam)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+2*StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+2*StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
for(unsigned short idx2=StensorSize;idx2!=2*StensorSize;++idx2){
partial_jacobian_epl(idx2,idx)=vect_e(idx2);
}
partial_jacobian_lam(idx)=vect_e(2*StensorSize);
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+2*StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_epl,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_lam,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_alp)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+2*StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+2*StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
for(unsigned short idx2=StensorSize;idx2!=2*StensorSize;++idx2){
partial_jacobian_epl(idx2,idx)=vect_e(idx2);
}
partial_jacobian_lam(idx)=vect_e(2*StensorSize);
partial_jacobian_alp(idx)=vect_e(1+2*StensorSize);
}
}

void additionalConvergenceChecks(bool&,real&,const SMType) const{
} // end of additionalConvergenceChecks

void computeThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 194 "MCBigoniMiniKHD.mfront"
this->sig=this->lambda*trace((this->eel+(this->theta)*(this->deel)))*StrainStensor::Id()+2.*this->mu*(this->eel+(this->theta)*(this->deel));
} // end of MCBigoniMiniKHD::computeThermodynamicForces

void computeFinalThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 194 "MCBigoniMiniKHD.mfront"
this->sig=this->lambda*trace(this->eel)*StrainStensor::Id()+2.*this->mu*this->eel;
} // end of MCBigoniMiniKHD::computeFinalThermodynamicForces

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->eel += this->deel;
this->epl += this->depl;
this->lam += this->dlam;
this->alp += this->dalp;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables(){
using namespace std;
using namespace tfel::math;
#line 482 "MCBigoniMiniKHD.mfront"
const real fh=(1.-this->alp)*(1.-this->alp)/pow(this->alp+this->rD,this->nD);
#line 483 "MCBigoniMiniKHD.mfront"
const real dfh_dalp=(1.-this->alp)*(this->alp*this->nD-2.*this->alp-2.*this->rD-this->nD)/pow(this->alp+this->rD,this->nD+1.);
#line 484 "MCBigoniMiniKHD.mfront"
const Stensor4 Hkin=fh*this->Ckin;
#line 485 "MCBigoniMiniKHD.mfront"
const Stensor4 dHkin_dalp=dfh_dalp*this->Ckin;
#line 486 "MCBigoniMiniKHD.mfront"
const StressStensor XASV=this->sig-(Hkin*(this->epl));
#line 487 "MCBigoniMiniKHD.mfront"
this->XeqASV=sigmaeq(XASV);
#line 488 "MCBigoniMiniKHD.mfront"
this->XmASV=trace(XASV)/3.;
#line 489 "MCBigoniMiniKHD.mfront"
this->YASV=-.5*((this->epl|dHkin_dalp)|this->epl);
#line 490 "MCBigoniMiniKHD.mfront"
this->niter=iter;
#line 491 "MCBigoniMiniKHD.mfront"
this->inst+=this->dt;
#line 492 "MCBigoniMiniKHD.mfront"
if (this->dlam>0) {
#line 493 "MCBigoniMiniKHD.mfront"
this->ip=1;
#line 494 "MCBigoniMiniKHD.mfront"
this->evp+=this->dlam*sin(this->psir);
#line 495 "MCBigoniMiniKHD.mfront"
this->gap+=this->dlam*sqrt(2.*deviator(this->nGtmp)|deviator(this->nGtmp)/3.);
#line 496 "MCBigoniMiniKHD.mfront"
} else {
#line 497 "MCBigoniMiniKHD.mfront"
this->ip=0;
#line 498 "MCBigoniMiniKHD.mfront"
}
#line 499 "MCBigoniMiniKHD.mfront"
if (this->b[0] && this->alp>=this->alpc) {
#line 500 "MCBigoniMiniKHD.mfront"
this->domain=3;
#line 501 "MCBigoniMiniKHD.mfront"
} else if (this->b[0] && this->alp<this->alpc) {
#line 502 "MCBigoniMiniKHD.mfront"
this->domain=1;
#line 503 "MCBigoniMiniKHD.mfront"
} else if (this->b[0] && this->b[1] && this->alp<this->alpc) {
#line 504 "MCBigoniMiniKHD.mfront"
this->domain=2;
#line 505 "MCBigoniMiniKHD.mfront"
} else {
#line 506 "MCBigoniMiniKHD.mfront"
this->domain=0;
#line 507 "MCBigoniMiniKHD.mfront"
}
}

//! \brief Default constructor (disabled)
MCBigoniMiniKHD() =delete ;
//! \brief Copy constructor (disabled)
MCBigoniMiniKHD(const MCBigoniMiniKHD&) = delete;
//! \brief Assignement operator (disabled)
MCBigoniMiniKHD& operator = (const MCBigoniMiniKHD&) = delete;

public:

/*!
* \brief Constructor
*/
MCBigoniMiniKHD(const MCBigoniMiniKHDBehaviourData<hypothesis,Type,false>& src1,
const MCBigoniMiniKHDIntegrationData<hypothesis,Type,false>& src2)
: MCBigoniMiniKHDBehaviourData<hypothesis,Type,false>(src1),
MCBigoniMiniKHDIntegrationData<hypothesis,Type,false>(src2),
deel(this->zeros),
depl(this->zeros),
dlam(this->zeros(2*StensorSize)),
dalp(this->zeros(1+2*StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->theta = MCBigoniMiniKHDParametersInitializer::get().theta;
this->epsilon = MCBigoniMiniKHDParametersInitializer::get().epsilon;
this->minimal_time_step_scaling_factor = MCBigoniMiniKHDParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = MCBigoniMiniKHDParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = MCBigoniMiniKHDParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = MCBigoniMiniKHDParametersInitializer::get().iterMax;
}

/*
 * \brief constructor for the Aster interface
 * \param[in] ASTERdt_: time increment
 * \param[in] ASTERT_: temperature
 * \param[in] ASTERdT_: temperature increment
 * \param[in] ASTERmat: material properties
 * \param[in] ASTERint_vars: state variables
 * \param[in] ASTERext_vars: external state variables
 * \param[in] ASTERdext_vars: external state variables increments
 */
MCBigoniMiniKHD(const Type* const ASTERdt_,
const Type* const ASTERT_,
const Type* const ASTERdT_,
const Type* const ASTERmat,
const Type* const ASTERint_vars,
const Type* const ASTERext_vars,
const Type* const ASTERdext_vars)
: MCBigoniMiniKHDBehaviourData<hypothesis,Type,false>(ASTERT_,ASTERmat,
ASTERint_vars,ASTERext_vars),
MCBigoniMiniKHDIntegrationData<hypothesis,Type,false>(ASTERdt_,ASTERdT_,ASTERdext_vars),
deel(this->zeros),
depl(this->zeros),
dlam(this->zeros(2*StensorSize)),
dalp(this->zeros(1+2*StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->theta = MCBigoniMiniKHDParametersInitializer::get().theta;
this->epsilon = MCBigoniMiniKHDParametersInitializer::get().epsilon;
this->minimal_time_step_scaling_factor = MCBigoniMiniKHDParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = MCBigoniMiniKHDParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = MCBigoniMiniKHDParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = MCBigoniMiniKHDParametersInitializer::get().iterMax;
}

/*!
 * \ brief initialize the behaviour with user code
 */
void initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 132 "MCBigoniMiniKHD.mfront"
using namespace tfel::material::lame;
#line 133 "MCBigoniMiniKHD.mfront"
this->local_zero_tolerance=real(1e-12);
#line 135 "MCBigoniMiniKHD.mfront"
this->pi=4.*atan(1.);
#line 136 "MCBigoniMiniKHD.mfront"
this->phir=this->phi*this->pi/180.;
#line 137 "MCBigoniMiniKHD.mfront"
this->psir=this->psi*this->pi/180.;
#line 139 "MCBigoniMiniKHD.mfront"
this->thetaFm=atan(-sin(this->phir)/sqrt(3.));
#line 140 "MCBigoniMiniKHD.mfront"
this->thetaGm=atan(-sin(this->psir)/sqrt(3.));
#line 141 "MCBigoniMiniKHD.mfront"
this->KFm=(cos(this->thetaFm)-sin(this->phir)*sin(this->thetaFm)/sqrt(3.));
#line 142 "MCBigoniMiniKHD.mfront"
this->KGm=(cos(this->thetaGm)-sin(this->psir)*sin(this->thetaGm)/sqrt(3.));
#line 144 "MCBigoniMiniKHD.mfront"
this->aG=this->at*tan(this->phir)/tan(this->psir);
#line 146 "MCBigoniMiniKHD.mfront"
this->bK=16./9.*(1.-this->nu*this->nu)/(1.-2.*this->nu);
#line 147 "MCBigoniMiniKHD.mfront"
this->bMu=32./45.*(1.-this->nu)*(5.-this->nu)/(2.-this->nu);
#line 149 "MCBigoniMiniKHD.mfront"
this->alpc=.995;
#line 150 "MCBigoniMiniKHD.mfront"
this->rD=1.e-4;
#line 152 "MCBigoniMiniKHD.mfront"
this->lambda=computeLambda(this->young,this->nu);
#line 153 "MCBigoniMiniKHD.mfront"
this->mu=computeMu(this->young,this->nu);
#line 154 "MCBigoniMiniKHD.mfront"
this->ks=this->lambda+2.*this->mu/3.;
#line 155 "MCBigoniMiniKHD.mfront"
this->Ce=3.*this->ks*Stensor4::J()+2.*this->mu*Stensor4::K();
#line 156 "MCBigoniMiniKHD.mfront"
this->Ckin=(3.*this->ks*Stensor4::J()/this->bK+2.*this->mu*Stensor4::K()/this->bMu)/this->qD;
#line 158 "MCBigoniMiniKHD.mfront"
if (this->inst==real(0) && this->lam==real(0)) {
#line 159 "MCBigoniMiniKHD.mfront"
const Stensor4 Se=invert(this->Ce);
#line 160 "MCBigoniMiniKHD.mfront"
this->eel=(Se*this->sig);
#line 161 "MCBigoniMiniKHD.mfront"
}
}

/*!
* \brief set the policy for "out of bounds" conditions
*/
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

/*!
* \brief check bounds
*/
void checkBounds() const{
} // end of checkBounds

IntegrationResult computePredictionOperator(const SMFlag,const SMType) override{
tfel::raise("MCBigoniMiniKHD::computePredictionOperator: "
"unsupported prediction operator flag");
}

real getMinimalTimeStepScalingFactor() const override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool,real>
computeAPrioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
 * \brief Integrate behaviour law over the time step
 */
IntegrationResult integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR,
"invalid tangent operator flag");
#line 171 "MCBigoniMiniKHD.mfront"
StressStensor sigel(this->lambda*trace(this->eel+this->deto)*Stensor::Id()+2.*this->mu*(this->eel+this->deto));
#line 174 "MCBigoniMiniKHD.mfront"
const real fh=(1.-this->alp)*(1.-this->alp)/pow(this->alp+this->rD,this->nD);
#line 175 "MCBigoniMiniKHD.mfront"
const Stensor4 Hkin=fh*this->Ckin;
#line 178 "MCBigoniMiniKHD.mfront"
const StressStensor Xel=sigel-(Hkin*this->epl);
#line 179 "MCBigoniMiniKHD.mfront"
const StressStensor Xdel=deviator(Xel);
#line 180 "MCBigoniMiniKHD.mfront"
const stress J2Xel=.5*(Xdel|Xdel);
#line 181 "MCBigoniMiniKHD.mfront"
const stress I1Xel=trace(Xel);
#line 184 "MCBigoniMiniKHD.mfront"
const stress RFel=sqrt(J2Xel*this->KFm*this->KFm+this->at*this->at*sin(this->phir)*sin(this->phir));
#line 185 "MCBigoniMiniKHD.mfront"
this->b[0]=RFel+I1Xel*sin(this->phir)/3.-this->coh*cos(this->phir)>real(0);
auto error = real{};
bool converged=false;
this->iter=0;
while((converged==false)&&
(this->iter<MCBigoniMiniKHD::iterMax)){
++(this->iter);
this->computeThermodynamicForces();
const auto computeFdF_ok = this->computeFdF(false);
if(computeFdF_ok){
error=norm(this->fzeros)/(real(2+2*StensorSize));
}
if((!computeFdF_ok)||(!ieee754::isfinite(error))){
if(this->iter==1){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
} else {
const real integrate_one_half = real(1)/real(2);
this->zeros -= (this->zeros-this->zeros_1)*integrate_one_half;
this->updateMaterialPropertiesDependantOnStateVariables();
}
} else {
this->zeros_1  = this->zeros;
converged = error<this->epsilon;
this->additionalConvergenceChecks(converged, error, smt);
if((!converged)||(smt!=NOSTIFFNESSREQUESTED)){
}
if(!converged){
try{
TinyMatrixSolve<2+2*StensorSize,real>::exe(this->jacobian,this->fzeros);
}
catch(LUException&){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->zeros -= this->fzeros;
this->updateMaterialPropertiesDependantOnStateVariables();
}
}
}
if(this->iter==this->iterMax){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->updateIntegrationVariables();
this->updateStateVariables();
this->computeFinalThermodynamicForces();
this->updateAuxiliaryStateVariables();
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
} // end of MCBigoniMiniKHD::integrate

/*!
* \brief compute fzeros and jacobian
*/
bool computeFdF(const bool perturbatedSystemEvaluation){
using namespace std;
using namespace tfel::math;
using std::vector;
// silent compiler warning
static_cast<void>(perturbatedSystemEvaluation); 
constexpr const auto eel_offset = 0;
static_cast<void>(eel_offset);
typename tfel::math::StensorFromTinyVectorView<N,2+2*StensorSize,0,real>::type feel(this->fzeros);
constexpr const auto epl_offset = StensorSize;
static_cast<void>(epl_offset);
typename tfel::math::StensorFromTinyVectorView<N,2+2*StensorSize,StensorSize,real>::type fepl(this->fzeros);
constexpr const auto lam_offset = 2*StensorSize;
static_cast<void>(lam_offset);
real& flam(this->fzeros(2*StensorSize));
constexpr const auto alp_offset = 1+2*StensorSize;
static_cast<void>(alp_offset);
real& falp(this->fzeros(1+2*StensorSize));
// derivative of variable feel by variable eel
typename tfel::math::ST2toST2FromTinyMatrixView<N,2+2*StensorSize,2+2*StensorSize,
0,0,real>::type dfeel_ddeel(this->jacobian);
// derivative of variable feel by variable epl
typename tfel::math::ST2toST2FromTinyMatrixView<N,2+2*StensorSize,2+2*StensorSize,
0,StensorSize,real>::type dfeel_ddepl(this->jacobian);
// derivative of variable feel by variable lam
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+2*StensorSize,2+2*StensorSize,
0,2*StensorSize,real>::type dfeel_ddlam(this->jacobian);
// derivative of variable feel by variable alp
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+2*StensorSize,2+2*StensorSize,
0,1+2*StensorSize,real>::type dfeel_ddalp(this->jacobian);
// derivative of variable fepl by variable eel
typename tfel::math::ST2toST2FromTinyMatrixView<N,2+2*StensorSize,2+2*StensorSize,
StensorSize,0,real>::type dfepl_ddeel(this->jacobian);
// derivative of variable fepl by variable epl
typename tfel::math::ST2toST2FromTinyMatrixView<N,2+2*StensorSize,2+2*StensorSize,
StensorSize,StensorSize,real>::type dfepl_ddepl(this->jacobian);
// derivative of variable fepl by variable lam
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+2*StensorSize,2+2*StensorSize,
StensorSize,2*StensorSize,real>::type dfepl_ddlam(this->jacobian);
// derivative of variable fepl by variable alp
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+2*StensorSize,2+2*StensorSize,
StensorSize,1+2*StensorSize,real>::type dfepl_ddalp(this->jacobian);
// derivative of variable flam by variable eel
typename tfel::math::StensorFromTinyMatrixRowView<N,2+2*StensorSize,2+2*StensorSize,
2*StensorSize,0,real>::type dflam_ddeel(this->jacobian);
// derivative of variable flam by variable epl
typename tfel::math::StensorFromTinyMatrixRowView<N,2+2*StensorSize,2+2*StensorSize,
2*StensorSize,StensorSize,real>::type dflam_ddepl(this->jacobian);
// derivative of variable flam by variable lam
real& dflam_ddlam = this->jacobian(2*StensorSize,2*StensorSize);
// derivative of variable flam by variable alp
real& dflam_ddalp = this->jacobian(2*StensorSize,1+2*StensorSize);
// derivative of variable falp by variable eel
typename tfel::math::StensorFromTinyMatrixRowView<N,2+2*StensorSize,2+2*StensorSize,
1+2*StensorSize,0,real>::type dfalp_ddeel(this->jacobian);
// derivative of variable falp by variable epl
typename tfel::math::StensorFromTinyMatrixRowView<N,2+2*StensorSize,2+2*StensorSize,
1+2*StensorSize,StensorSize,real>::type dfalp_ddepl(this->jacobian);
// derivative of variable falp by variable lam
real& dfalp_ddlam = this->jacobian(1+2*StensorSize,2*StensorSize);
// derivative of variable falp by variable alp
real& dfalp_ddalp = this->jacobian(1+2*StensorSize,1+2*StensorSize);
// setting jacobian to identity
std::fill(this->jacobian.begin(),this->jacobian.end(),real(0));
for(unsigned short idx = 0; idx!=2+2*StensorSize;++idx){
this->jacobian(idx,idx)= real(1);
}
// setting f values to zeros
this->fzeros = this->zeros;
#line 204 "MCBigoniMiniKHD.mfront"
if ((this->b)[0] && (this->alp)>=(this->alpc)){
#line 207 "MCBigoniMiniKHD.mfront"
const real fh=(1.-(this->alpc))*(1.-(this->alpc))/pow((this->alpc)+(this->rD),(this->nD));
#line 208 "MCBigoniMiniKHD.mfront"
const Stensor4 Hkin=fh*(this->Ckin);
#line 211 "MCBigoniMiniKHD.mfront"
const StressStensor X=(this->sig)-(Hkin*((this->epl)+(this->depl)));
#line 212 "MCBigoniMiniKHD.mfront"
const StressStensor Xd=deviator(X);
#line 213 "MCBigoniMiniKHD.mfront"
const stress J2X=.5*(Xd|Xd);
#line 214 "MCBigoniMiniKHD.mfront"
const stress I1X=trace(X);
#line 217 "MCBigoniMiniKHD.mfront"
const stress RF=sqrt(J2X*(this->KFm)*(this->KFm)+(this->at)*(this->at)*sin((this->phir))*sin((this->phir)));
#line 218 "MCBigoniMiniKHD.mfront"
const stress RG=sqrt(J2X*(this->KGm)*(this->KGm)+(this->at)*(this->aG)*sin((this->psir))*sin((this->psir)));
#line 219 "MCBigoniMiniKHD.mfront"
const stress F=RF+I1X*sin((this->phir))/3.-(this->coh)*cos((this->phir));
#line 222 "MCBigoniMiniKHD.mfront"
const real dG_dI1X=sin((this->psir))/3.;
#line 223 "MCBigoniMiniKHD.mfront"
const real dG_dJ2X=.5*(this->KGm)*(this->KGm)/max(RG,(this->local_zero_tolerance));
#line 224 "MCBigoniMiniKHD.mfront"
const Stensor nG=dG_dI1X*Stensor::Id()+dG_dJ2X*Xd;
#line 225 "MCBigoniMiniKHD.mfront"
(this->nGtmp)=nG;
#line 228 "MCBigoniMiniKHD.mfront"
feel=(this->deel)-(this->deto)+(this->dlam)*nG;
#line 229 "MCBigoniMiniKHD.mfront"
fepl=(this->depl)-(this->dlam)*nG;
#line 230 "MCBigoniMiniKHD.mfront"
flam=F/(this->young);
#line 231 "MCBigoniMiniKHD.mfront"
falp=(this->dalp);
#line 239 "MCBigoniMiniKHD.mfront"
const Stensor4 dX_dsig=Stensor4::Id();
#line 240 "MCBigoniMiniKHD.mfront"
const real dG_ddJ2X=-.5*(this->KGm)*(this->KGm)*dG_dJ2X/max(RG,(this->local_zero_tolerance))/max(RG,(this->local_zero_tolerance));
#line 241 "MCBigoniMiniKHD.mfront"
const Stensor4 dnG_dX=dG_ddJ2X*(Xd^Xd)+dG_dJ2X*Stensor4::K();
#line 242 "MCBigoniMiniKHD.mfront"
const Stensor4 dnG_dsig=(dnG_dX*dX_dsig);
#line 244 "MCBigoniMiniKHD.mfront"
const Stensor4 dX_ddepl=-Hkin;
#line 245 "MCBigoniMiniKHD.mfront"
const Stensor4 dnG_ddepl=(dnG_dX*dX_ddepl);
#line 247 "MCBigoniMiniKHD.mfront"
const real dF_dI1X=sin((this->phir))/3.;
#line 248 "MCBigoniMiniKHD.mfront"
const real dF_dJ2X=.5*(this->KFm)*(this->KFm)/max(RF,(this->local_zero_tolerance));
#line 249 "MCBigoniMiniKHD.mfront"
const Stensor dF_dX=dF_dI1X*Stensor::Id()+dF_dJ2X*Xd;
#line 250 "MCBigoniMiniKHD.mfront"
const Stensor dF_dsig=(dF_dX|dX_dsig);
#line 252 "MCBigoniMiniKHD.mfront"
const Stensor dF_ddepl=(dF_dX|dX_ddepl);
#line 255 "MCBigoniMiniKHD.mfront"
dfeel_ddeel=Stensor4::Id()+(this->dlam)*(dnG_dsig*(this->Ce));
#line 256 "MCBigoniMiniKHD.mfront"
dfeel_ddepl=(this->dlam)*dnG_ddepl;
#line 257 "MCBigoniMiniKHD.mfront"
dfeel_ddlam=nG;
#line 258 "MCBigoniMiniKHD.mfront"
dfeel_ddalp=Stensor(real(0));
#line 261 "MCBigoniMiniKHD.mfront"
dfepl_ddeel=-(this->dlam)*(dnG_dsig*(this->Ce));
#line 262 "MCBigoniMiniKHD.mfront"
dfepl_ddepl=Stensor4::Id()-(this->dlam)*dnG_ddepl;
#line 263 "MCBigoniMiniKHD.mfront"
dfepl_ddlam=-nG;
#line 264 "MCBigoniMiniKHD.mfront"
dfepl_ddalp=Stensor(real(0));
#line 267 "MCBigoniMiniKHD.mfront"
dflam_ddeel=(dF_dsig|(this->Ce))/(this->young);
#line 268 "MCBigoniMiniKHD.mfront"
dflam_ddepl=dF_ddepl/(this->young);
#line 269 "MCBigoniMiniKHD.mfront"
dflam_ddlam=real(0);
#line 270 "MCBigoniMiniKHD.mfront"
dflam_ddalp=real(0);
#line 273 "MCBigoniMiniKHD.mfront"
dfalp_ddeel=Stensor(real(0));
#line 274 "MCBigoniMiniKHD.mfront"
dfalp_ddepl=Stensor(real(0));
#line 275 "MCBigoniMiniKHD.mfront"
dfalp_ddlam=real(0);
#line 276 "MCBigoniMiniKHD.mfront"
dfalp_ddalp=real(1);
#line 280 "MCBigoniMiniKHD.mfront"
}
#line 283 "MCBigoniMiniKHD.mfront"
if ((this->b)[0] && (this->alp)<(this->alpc)){
#line 286 "MCBigoniMiniKHD.mfront"
const real fh=(1.-(this->alp))*(1.-(this->alp))/pow((this->alp)+(this->rD),(this->nD));
#line 287 "MCBigoniMiniKHD.mfront"
const real dfh_dalp=(1.-(this->alp))*((this->alp)*(this->nD)-2.*(this->alp)-2.*(this->rD)-(this->nD))/pow((this->alp)+(this->rD),(this->nD)+1.);
#line 288 "MCBigoniMiniKHD.mfront"
const Stensor4 Hkin=fh*(this->Ckin);
#line 289 "MCBigoniMiniKHD.mfront"
const Stensor4 dHkin_dalp=dfh_dalp*(this->Ckin);
#line 292 "MCBigoniMiniKHD.mfront"
const StressStensor X=(this->sig)-(Hkin*((this->epl)+(this->depl)));
#line 293 "MCBigoniMiniKHD.mfront"
const stress Y=-.5*(((this->epl)+(this->depl))|dHkin_dalp)|((this->epl)+(this->depl));
#line 294 "MCBigoniMiniKHD.mfront"
const StressStensor Xd=deviator(X);
#line 295 "MCBigoniMiniKHD.mfront"
const stress J2X=.5*(Xd|Xd);
#line 296 "MCBigoniMiniKHD.mfront"
const stress I1X=trace(X);
#line 299 "MCBigoniMiniKHD.mfront"
const stress RF=sqrt(J2X*(this->KFm)*(this->KFm)+(this->at)*(this->at)*sin((this->phir))*sin((this->phir)));
#line 300 "MCBigoniMiniKHD.mfront"
const stress RG=sqrt(J2X*(this->KGm)*(this->KGm)+(this->at)*(this->aG)*sin((this->psir))*sin((this->psir)));
#line 301 "MCBigoniMiniKHD.mfront"
const stress F=RF+I1X*sin((this->phir))/3.-(this->coh)*cos((this->phir));
#line 304 "MCBigoniMiniKHD.mfront"
const real dG_dI1X=sin((this->psir))/3.;
#line 305 "MCBigoniMiniKHD.mfront"
const real dG_dJ2X=.5*(this->KGm)*(this->KGm)/max(RG,(this->local_zero_tolerance));
#line 306 "MCBigoniMiniKHD.mfront"
const Stensor nG=dG_dI1X*Stensor::Id()+dG_dJ2X*Xd;
#line 307 "MCBigoniMiniKHD.mfront"
(this->nGtmp)=nG;
#line 310 "MCBigoniMiniKHD.mfront"
(this->b)[1]=Y-(this->Yc)>real(0);
#line 313 "MCBigoniMiniKHD.mfront"
feel=(this->deel)-(this->deto)+(this->dlam)*nG;
#line 314 "MCBigoniMiniKHD.mfront"
fepl=(this->depl)-(this->dlam)*nG;
#line 315 "MCBigoniMiniKHD.mfront"
flam=F/(this->young);
#line 316 "MCBigoniMiniKHD.mfront"
falp=(this->dalp);
#line 324 "MCBigoniMiniKHD.mfront"
const Stensor4 dX_dsig=Stensor4::Id();
#line 325 "MCBigoniMiniKHD.mfront"
const real dG_ddJ2X=-.5*(this->KGm)*(this->KGm)*dG_dJ2X/max(RG,(this->local_zero_tolerance))/max(RG,(this->local_zero_tolerance));
#line 326 "MCBigoniMiniKHD.mfront"
const Stensor4 dnG_dX=dG_ddJ2X*(Xd^Xd)+dG_dJ2X*Stensor4::K();
#line 327 "MCBigoniMiniKHD.mfront"
const Stensor4 dnG_dsig=(dnG_dX*dX_dsig);
#line 329 "MCBigoniMiniKHD.mfront"
const Stensor4 dX_ddepl=-Hkin;
#line 330 "MCBigoniMiniKHD.mfront"
const Stensor4 dnG_ddepl=(dnG_dX*dX_ddepl);
#line 332 "MCBigoniMiniKHD.mfront"
const real dF_dI1X=sin((this->phir))/3.;
#line 333 "MCBigoniMiniKHD.mfront"
const real dF_dJ2X=.5*(this->KFm)*(this->KFm)/max(RF,(this->local_zero_tolerance));
#line 334 "MCBigoniMiniKHD.mfront"
const Stensor dF_dX=dF_dI1X*Stensor::Id()+dF_dJ2X*Xd;
#line 335 "MCBigoniMiniKHD.mfront"
const Stensor dF_dsig=(dF_dX|dX_dsig);
#line 337 "MCBigoniMiniKHD.mfront"
const Stensor dF_ddepl=(dF_dX|dX_ddepl);
#line 340 "MCBigoniMiniKHD.mfront"
dfeel_ddeel=Stensor4::Id()+(this->dlam)*(dnG_dsig*(this->Ce));
#line 341 "MCBigoniMiniKHD.mfront"
dfeel_ddepl=(this->dlam)*dnG_ddepl;
#line 342 "MCBigoniMiniKHD.mfront"
dfeel_ddlam=nG;
#line 343 "MCBigoniMiniKHD.mfront"
dfeel_ddalp=Stensor(real(0));
#line 346 "MCBigoniMiniKHD.mfront"
dfepl_ddeel=-(this->dlam)*(dnG_dsig*(this->Ce));
#line 347 "MCBigoniMiniKHD.mfront"
dfepl_ddepl=Stensor4::Id()-(this->dlam)*dnG_ddepl;
#line 348 "MCBigoniMiniKHD.mfront"
dfepl_ddlam=-nG;
#line 349 "MCBigoniMiniKHD.mfront"
dfepl_ddalp=Stensor(real(0));
#line 352 "MCBigoniMiniKHD.mfront"
dflam_ddeel=(dF_dsig|(this->Ce))/(this->young);
#line 353 "MCBigoniMiniKHD.mfront"
dflam_ddepl=dF_ddepl/(this->young);
#line 354 "MCBigoniMiniKHD.mfront"
dflam_ddlam=real(0);
#line 355 "MCBigoniMiniKHD.mfront"
dflam_ddalp=real(0);
#line 358 "MCBigoniMiniKHD.mfront"
dfalp_ddeel=Stensor(real(0));
#line 359 "MCBigoniMiniKHD.mfront"
dfalp_ddepl=Stensor(real(0));
#line 360 "MCBigoniMiniKHD.mfront"
dfalp_ddlam=real(0);
#line 361 "MCBigoniMiniKHD.mfront"
dfalp_ddalp=real(1);
#line 365 "MCBigoniMiniKHD.mfront"
}
#line 368 "MCBigoniMiniKHD.mfront"
if ((this->b)[0] && (this->b)[1] && (this->alp)<(this->alpc)){
#line 371 "MCBigoniMiniKHD.mfront"
const real fh=(1.-(this->alp)-(this->dalp))*(1.-(this->alp)-(this->dalp))/pow((this->alp)+(this->dalp)+(this->rD),(this->nD));
#line 372 "MCBigoniMiniKHD.mfront"
const real dfh_dalp=(1.-(this->alp)-(this->dalp))*(((this->alp)+(this->dalp))*(this->nD)-2.*((this->alp)+(this->dalp))-2.*(this->rD)-(this->nD))/pow((this->alp)+(this->dalp)+(this->rD),(this->nD)+1.);
#line 373 "MCBigoniMiniKHD.mfront"
const Stensor4 Hkin=fh*(this->Ckin);
#line 374 "MCBigoniMiniKHD.mfront"
const Stensor4 dHkin_dalp=dfh_dalp*(this->Ckin);
#line 377 "MCBigoniMiniKHD.mfront"
const StressStensor X=(this->sig)-(Hkin*((this->epl)+(this->depl)));
#line 378 "MCBigoniMiniKHD.mfront"
const stress Y=-.5*(((this->epl)+(this->depl))|dHkin_dalp)|((this->epl)+(this->depl));
#line 379 "MCBigoniMiniKHD.mfront"
const StressStensor Xd=deviator(X);
#line 380 "MCBigoniMiniKHD.mfront"
const stress J2X=.5*(Xd|Xd);
#line 381 "MCBigoniMiniKHD.mfront"
const stress I1X=trace(X);
#line 384 "MCBigoniMiniKHD.mfront"
const stress RF=sqrt(J2X*(this->KFm)*(this->KFm)+(this->at)*(this->at)*sin((this->phir))*sin((this->phir)));
#line 385 "MCBigoniMiniKHD.mfront"
const stress RG=sqrt(J2X*(this->KGm)*(this->KGm)+(this->at)*(this->aG)*sin((this->psir))*sin((this->psir)));
#line 386 "MCBigoniMiniKHD.mfront"
const stress F=RF+I1X*sin((this->phir))/3.-(this->coh)*cos((this->phir));
#line 389 "MCBigoniMiniKHD.mfront"
const real dG_dI1X=sin((this->psir))/3.;
#line 390 "MCBigoniMiniKHD.mfront"
const real dG_dJ2X=.5*(this->KGm)*(this->KGm)/max(RG,(this->local_zero_tolerance));
#line 391 "MCBigoniMiniKHD.mfront"
const Stensor nG=dG_dI1X*Stensor::Id()+dG_dJ2X*Xd;
#line 392 "MCBigoniMiniKHD.mfront"
(this->nGtmp)=nG;
#line 395 "MCBigoniMiniKHD.mfront"
const stress Fd=Y-(this->Yc);
#line 398 "MCBigoniMiniKHD.mfront"
feel=(this->deel)-(this->deto)+(this->dlam)*nG;
#line 399 "MCBigoniMiniKHD.mfront"
fepl=(this->depl)-(this->dlam)*nG;
#line 400 "MCBigoniMiniKHD.mfront"
flam=F/(this->young);
#line 401 "MCBigoniMiniKHD.mfront"
falp=Fd/(this->young);
#line 409 "MCBigoniMiniKHD.mfront"
const Stensor4 dX_dsig=Stensor4::Id();
#line 410 "MCBigoniMiniKHD.mfront"
const real dG_ddJ2X=-.5*(this->KGm)*(this->KGm)*dG_dJ2X/max(RG,(this->local_zero_tolerance))/max(RG,(this->local_zero_tolerance));
#line 411 "MCBigoniMiniKHD.mfront"
const Stensor4 dnG_dX=dG_ddJ2X*(Xd^Xd)+dG_dJ2X*Stensor4::K();
#line 412 "MCBigoniMiniKHD.mfront"
const Stensor4 dnG_dsig=(dnG_dX*dX_dsig);
#line 414 "MCBigoniMiniKHD.mfront"
const Stensor4 dX_ddepl=-Hkin;
#line 415 "MCBigoniMiniKHD.mfront"
const Stensor4 dnG_ddepl=(dnG_dX*dX_ddepl);
#line 417 "MCBigoniMiniKHD.mfront"
const Stensor4 dHkin_ddalp=dHkin_dalp;
#line 418 "MCBigoniMiniKHD.mfront"
const StressStensor dX_ddalp=-(dHkin_ddalp*((this->epl)+(this->depl)));
#line 419 "MCBigoniMiniKHD.mfront"
const Stensor dnG_ddalp=(dnG_dX*dX_ddalp);
#line 421 "MCBigoniMiniKHD.mfront"
const real dF_dI1X=sin((this->phir))/3.;
#line 422 "MCBigoniMiniKHD.mfront"
const real dF_dJ2X=.5*(this->KFm)*(this->KFm)/max(RF,(this->local_zero_tolerance));
#line 423 "MCBigoniMiniKHD.mfront"
const Stensor dF_dX=dF_dI1X*Stensor::Id()+dF_dJ2X*Xd;
#line 424 "MCBigoniMiniKHD.mfront"
const Stensor dF_dsig=(dF_dX|dX_dsig);
#line 426 "MCBigoniMiniKHD.mfront"
const Stensor dF_ddepl=(dF_dX|dX_ddepl);
#line 428 "MCBigoniMiniKHD.mfront"
const real dF_ddalp=(dF_dX|dX_ddalp);
#line 430 "MCBigoniMiniKHD.mfront"
const real dFd_dY=real(1);
#line 432 "MCBigoniMiniKHD.mfront"
const Stensor dY_ddepl=-(dHkin_dalp*((this->epl)+(this->depl)));
#line 434 "MCBigoniMiniKHD.mfront"
const real d2fh_ddalp_dalp=(((this->alp)+(this->dalp))*((this->alp)+(this->dalp))*((this->nD)*((this->nD)-3.)+2.)+2.*((this->alp)+(this->dalp))*(-2.*(this->rD)*((this->nD)-1.)-(this->nD)*((this->nD)-1.))+2.*(this->rD)*((this->rD)+2.*(this->nD))+(this->nD)*((this->nD)+1.))/pow((this->alp)+(this->dalp)+(this->rD),(this->nD)+2.);
#line 435 "MCBigoniMiniKHD.mfront"
const Stensor4 d2Hkin_ddalp_dalp=d2fh_ddalp_dalp*(this->Ckin);
#line 436 "MCBigoniMiniKHD.mfront"
const stress dY_ddalp=-.5*(((this->epl)+(this->depl))|d2Hkin_ddalp_dalp)|((this->epl)+(this->depl));
#line 439 "MCBigoniMiniKHD.mfront"
dfeel_ddeel=Stensor4::Id()+(this->dlam)*(dnG_dsig*(this->Ce));
#line 440 "MCBigoniMiniKHD.mfront"
dfeel_ddepl=(this->dlam)*dnG_ddepl;
#line 441 "MCBigoniMiniKHD.mfront"
dfeel_ddlam=nG;
#line 442 "MCBigoniMiniKHD.mfront"
dfeel_ddalp=(this->dlam)*dnG_ddalp;
#line 445 "MCBigoniMiniKHD.mfront"
dfepl_ddeel=-(this->dlam)*(dnG_dsig*(this->Ce));
#line 446 "MCBigoniMiniKHD.mfront"
dfepl_ddepl=Stensor4::Id()-(this->dlam)*dnG_ddepl;
#line 447 "MCBigoniMiniKHD.mfront"
dfepl_ddlam=-nG;
#line 448 "MCBigoniMiniKHD.mfront"
dfepl_ddalp=-(this->dlam)*dnG_ddalp;
#line 451 "MCBigoniMiniKHD.mfront"
dflam_ddeel=(dF_dsig|(this->Ce))/(this->young);
#line 452 "MCBigoniMiniKHD.mfront"
dflam_ddepl=dF_ddepl/(this->young);
#line 453 "MCBigoniMiniKHD.mfront"
dflam_ddlam=real(0);
#line 454 "MCBigoniMiniKHD.mfront"
dflam_ddalp=dF_ddalp/(this->young);
#line 457 "MCBigoniMiniKHD.mfront"
dfalp_ddeel=Stensor(real(0));
#line 458 "MCBigoniMiniKHD.mfront"
dfalp_ddepl=(dFd_dY*dY_ddepl)/(this->young);
#line 459 "MCBigoniMiniKHD.mfront"
dfalp_ddlam=real(0);
#line 460 "MCBigoniMiniKHD.mfront"
dfalp_ddalp=(dFd_dY*dY_ddalp)/(this->young);
#line 464 "MCBigoniMiniKHD.mfront"
}
#line 467 "MCBigoniMiniKHD.mfront"
if (not (this->b)[0]){
#line 469 "MCBigoniMiniKHD.mfront"
feel=(this->deel)-(this->deto);
#line 470 "MCBigoniMiniKHD.mfront"
fepl=(this->depl);
#line 471 "MCBigoniMiniKHD.mfront"
flam=(this->dlam);
#line 472 "MCBigoniMiniKHD.mfront"
falp=(this->dalp);
#line 474 "MCBigoniMiniKHD.mfront"
}
static_cast<void>(dfeel_ddeel); /* suppress potential warnings */
static_cast<void>(dfeel_ddepl); /* suppress potential warnings */
static_cast<void>(dfeel_ddlam); /* suppress potential warnings */
static_cast<void>(dfeel_ddalp); /* suppress potential warnings */
static_cast<void>(dfepl_ddeel); /* suppress potential warnings */
static_cast<void>(dfepl_ddepl); /* suppress potential warnings */
static_cast<void>(dfepl_ddlam); /* suppress potential warnings */
static_cast<void>(dfepl_ddalp); /* suppress potential warnings */
static_cast<void>(dflam_ddeel); /* suppress potential warnings */
static_cast<void>(dflam_ddepl); /* suppress potential warnings */
static_cast<void>(dflam_ddlam); /* suppress potential warnings */
static_cast<void>(dflam_ddalp); /* suppress potential warnings */
static_cast<void>(dfalp_ddeel); /* suppress potential warnings */
static_cast<void>(dfalp_ddepl); /* suppress potential warnings */
static_cast<void>(dfalp_ddlam); /* suppress potential warnings */
static_cast<void>(dfalp_ddalp); /* suppress potential warnings */
return true;
}

std::pair<bool,real>
computeAPosterioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(real& Psi_s) const
{
Psi_s=0;
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(real& Psi_d) const
{
Psi_d=0;
}

bool computeConsistentTangentOperator(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
TinyPermutation<2+2*StensorSize> jacobian_permutation;
TinyMatrixSolve<2+2*StensorSize,real>::decomp(this->jacobian,jacobian_permutation);
struct TFEL_VISIBILITY_LOCAL GetPartialJacobianInvert{
GetPartialJacobianInvert(MCBigoniMiniKHD& b,
const tfel::math::TinyPermutation<2+2*StensorSize>& p)
: behaviour(b),
permutation(p)
{}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_epl){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_epl);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_epl,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_lam){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_epl,
partial_jacobian_lam);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_epl,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_lam,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_alp){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_epl,
partial_jacobian_lam,
partial_jacobian_alp);
}
private:
MCBigoniMiniKHD& behaviour;
const tfel::math::TinyPermutation<2+2*StensorSize>& permutation;
}; // end of struct GetPartialJacobianInvert
GetPartialJacobianInvert getPartialJacobianInvert(*this, jacobian_permutation);
#line 515 "MCBigoniMiniKHD.mfront"
if((smt==ELASTIC)||(smt==SECANTOPERATOR)) {
#line 516 "MCBigoniMiniKHD.mfront"
computeElasticStiffness<N,Type>::exe((this->Dt),(this->lambda),(this->mu));
#line 517 "MCBigoniMiniKHD.mfront"
}
#line 518 "MCBigoniMiniKHD.mfront"
else if (smt==CONSISTENTTANGENTOPERATOR) {
#line 519 "MCBigoniMiniKHD.mfront"
Stensor4 Je;
#line 520 "MCBigoniMiniKHD.mfront"
getPartialJacobianInvert(Je);
#line 521 "MCBigoniMiniKHD.mfront"
(this->Dt)=(this->Ce)*Je;
#line 522 "MCBigoniMiniKHD.mfront"
}
#line 523 "MCBigoniMiniKHD.mfront"
else {
#line 524 "MCBigoniMiniKHD.mfront"
return false;
#line 525 "MCBigoniMiniKHD.mfront"
}
return true;
}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->eto  += this->deto;
this->T += this->dT;
}

//!
~MCBigoniMiniKHD()
 override = default;

private:

std::pair<bool,real> computeAPrioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

std::pair<bool,real> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = None;
}; // end of MCBigoniMiniKHD class

template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
operator <<(std::ostream& os,const MCBigoniMiniKHD<hypothesis,Type,false>& b)
{
os << " : " << b.eto << '\n';
os << " : " << b.deto << '\n';
os << " : " << b.sig << '\n';
os << "t : " << b.dt << '\n';
os << "young : " << b.young << '\n';
os << "nu : " << b.nu << '\n';
os << "phi : " << b.phi << '\n';
os << "psi : " << b.psi << '\n';
os << "coh : " << b.coh << '\n';
os << "at : " << b.at << '\n';
os << "Yc : " << b.Yc << '\n';
os << "nD : " << b.nD << '\n';
os << "qD : " << b.qD << '\n';
os << " : " << b.eel << '\n';
os << " : " << b.deel << '\n';
os << "epl : " << b.epl << '\n';
os << "epl : " << b.depl << '\n';
os << "lam : " << b.lam << '\n';
os << "lam : " << b.dlam << '\n';
os << "alp : " << b.alp << '\n';
os << "alp : " << b.dalp << '\n';
os << "niter : " << b.niter << '\n';
os << "ip : " << b.ip << '\n';
os << "evp : " << b.evp << '\n';
os << "gap : " << b.gap << '\n';
os << "inst : " << b.inst << '\n';
os << "domain : " << b.domain << '\n';
os << "XeqASV : " << b.XeqASV << '\n';
os << "XmASV : " << b.XmASV << '\n';
os << "YASV : " << b.YASV << '\n';
os << "T : " << b.T << '\n';
os << "T : " << b.dT << '\n';
os << "Ce : " << b.Ce << '\n';
os << "Ckin : " << b.Ckin << '\n';
os << "nGtmp : " << b.nGtmp << '\n';
os << " : " << b.theta << '\n';
os << " : " << b.epsilon << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "numerical_jacobian_epsilon : " << b.numerical_jacobian_epsilon << '\n';
os << "iterMax : " << b.iterMax << '\n';
return os;
}

/*!
* Partial specialisation for MCBigoniMiniKHD.
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class MechanicalBehaviourTraits<MCBigoniMiniKHD<hypothesis,Type,false> >
{
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 9;
static constexpr unsigned short internal_variables_nb  = 11+2*StensorSize;
static constexpr unsigned short external_variables_nb  = 1;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "MCBigoniMiniKHD";
}

};

/*!
* Partial specialisation for MCBigoniMiniKHD.
*/
template<typename Type>
class MechanicalBehaviourTraits<MCBigoniMiniKHD<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 0;
static constexpr unsigned short external_variables_nb  = 0;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "MCBigoniMiniKHD";
}

};

/*!
* Partial specialisation for MCBigoniMiniKHD.
*/
template<typename Type>
class MechanicalBehaviourTraits<MCBigoniMiniKHD<ModellingHypothesis::PLANESTRESS,Type,false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 0;
static constexpr unsigned short external_variables_nb  = 0;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "MCBigoniMiniKHD";
}

};

} // end of namespace material

} // end of namespace tfel

#endif /* LIB_TFELMATERIAL_MCBIGONIMINIKHD_HXX */
