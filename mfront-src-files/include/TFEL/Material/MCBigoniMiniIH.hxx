/*!
* \file   TFEL/Material/MCBigoniMiniIH.hxx
* \brief  this file implements the MCBigoniMiniIH Behaviour.
*         File generated by tfel version 3.4.0
* \author Simon Raude
* \date   07 / 10 / 2022
 */

#ifndef LIB_TFELMATERIAL_MCBIGONIMINIIH_HXX
#define LIB_TFELMATERIAL_MCBIGONIMINIIH_HXX

#include<string>
#include<iostream>
#include<limits>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/Metaprogramming/StaticAssert.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Material/MaterialException.hxx"
#include"TFEL/Material/MechanicalBehaviour.hxx"
#include"TFEL/Material/MechanicalBehaviourTraits.hxx"
#include"TFEL/Material/OutOfBoundsPolicy.hxx"
#include"TFEL/Material/BoundsCheck.hxx"
#include"TFEL/Material/IsotropicPlasticity.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/Hosford1972YieldCriterion.hxx"
#include"TFEL/Material/MCBigoniMiniIHBehaviourData.hxx"
#include"TFEL/Material/MCBigoniMiniIHIntegrationData.hxx"

#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Math/Vector/TinyVectorFromTinyVectorView.hxx"
#include"TFEL/Math/Vector/TinyVectorFromTinyVectorViewIO.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyVectorView.hxx"
#include "TFEL/Math/Stensor/StensorFromTinyMatrixRowView.hxx"
#include "TFEL/Math/Stensor/StensorFromTinyMatrixRowView2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2FromTinyMatrixView.hxx"

#include"TFEL/Math/ST2toST2/ST2toST2FromTinyMatrixView2.hxx"

#include"TFEL/Math/Stensor/StensorFromTinyMatrixColumnView.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixRowView.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixColumnView2.hxx"
#include"TFEL/Math/Stensor/StensorFromTinyMatrixRowView2.hxx"
#include"TFEL/Math/Vector/TinyVectorOfStensorFromTinyVectorView.hxx"
#include"TFEL/Math/Vector/TinyVectorOfStensorFromTinyVectorViewIO.hxx"
#line 100 "MCBigoniMiniIH.mfront"
#include"TFEL/Material/Lame.hxx"

#include"MFront/Aster/Aster.hxx"

namespace tfel{

namespace material{

struct MCBigoniMiniIHParametersInitializer
{
static MCBigoniMiniIHParametersInitializer&
get();

double theta;
double epsilon;
double minimal_time_step_scaling_factor;
double maximal_time_step_scaling_factor;
double numerical_jacobian_epsilon;
unsigned short iterMax;

void set(const char* const,const double);

void set(const char* const,const unsigned short);

/*!
 * \brief convert a string to double
 * \param[in] p : parameter
 * \param[in] v : value
 */
static double getDouble(const std::string&,const std::string&);
/*!
 * \brief convert a string to unsigned short
 * \param[in] p : parameter
 * \param[in] v : value
 */
static unsigned short getUnsignedShort(const std::string&,const std::string&);
private :

MCBigoniMiniIHParametersInitializer();

MCBigoniMiniIHParametersInitializer(const MCBigoniMiniIHParametersInitializer&);

MCBigoniMiniIHParametersInitializer&
operator=(const MCBigoniMiniIHParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(MCBigoniMiniIHParametersInitializer&,const char* const);
};

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis,typename Type,bool use_qt>
class MCBigoniMiniIH;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
 operator <<(std::ostream&,const MCBigoniMiniIH<hypothesis,Type,false>&);

/*!
* \class MCBigoniMiniIH
* \brief This class implements the MCBigoniMiniIH behaviour.
* \param hypothesis, modelling hypothesis.
* \param Type, numerical type.
* \author Simon Raude
* \date   07 / 10 / 2022
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class MCBigoniMiniIH<hypothesis,Type,false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>,
public MCBigoniMiniIHBehaviourData<hypothesis,Type,false>,
public MCBigoniMiniIHIntegrationData<hypothesis,Type,false>
{

static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

TFEL_STATIC_ASSERT(N==1||N==2||N==3);
TFEL_STATIC_ASSERT(tfel::typetraits::IsFundamentalNumericType<Type>::cond);
TFEL_STATIC_ASSERT(tfel::typetraits::IsReal<Type>::cond);

friend std::ostream& operator<< <>(std::ostream&,const MCBigoniMiniIH&);

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N,Type,false>;
using real                = typename Types::real;
using time                = typename Types::time;
using length              = typename Types::length;
using frequency           = typename Types::frequency;
using stress              = typename Types::stress;
using strain              = typename Types::strain;
using strainrate          = typename Types::strainrate;
using stressrate          = typename Types::stressrate;
using temperature         = typename Types::temperature;
using thermalexpansion    = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity         = typename Types::massdensity;
using energydensity         = typename Types::energydensity;
using TVector             = typename Types::TVector;
using Stensor             = typename Types::Stensor;
using Stensor4            = typename Types::Stensor4;
using FrequencyStensor    = typename Types::FrequencyStensor;
using ForceTVector        = typename Types::ForceTVector;
using StressStensor       = typename Types::StressStensor;
using StressRateStensor   = typename Types::StressRateStensor;
using DisplacementTVector = typename Types::DisplacementTVector;
using StrainStensor       = typename Types::StrainStensor;
using StrainRateStensor   = typename Types::StrainRateStensor;
using StiffnessTensor     = typename Types::StiffnessTensor;
using Tensor              = typename Types::Tensor;
using FrequencyTensor     = typename Types::FrequencyTensor;
using StressTensor        = typename Types::StressTensor;
using ThermalExpansionCoefficientTensor = typename Types::ThermalExpansionCoefficientTensor;
using DeformationGradientTensor         = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor     = typename Types::DeformationGradientRateTensor;
using TemperatureGradient = typename Types::TemperatureGradient;
using HeatFlux = typename Types::HeatFlux;
using TangentOperator   = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<real>;

public :

typedef MCBigoniMiniIHBehaviourData<hypothesis,Type,false> BehaviourData;
typedef MCBigoniMiniIHIntegrationData<hypothesis,Type,false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :



typename tfel::math::StensorFromTinyVectorView<N,2+StensorSize,0,real>::type deel;
#line 76 "MCBigoniMiniIH.mfront"
real& dlam;
#line 77 "MCBigoniMiniIH.mfront"
real& dgap;

#line 57 "MCBigoniMiniIH.mfront"
bool b;
#line 58 "MCBigoniMiniIH.mfront"
real local_zero_tolerance;
#line 59 "MCBigoniMiniIH.mfront"
real pi;
#line 60 "MCBigoniMiniIH.mfront"
real phir;
#line 61 "MCBigoniMiniIH.mfront"
real psir;
#line 62 "MCBigoniMiniIH.mfront"
real thetaFm;
#line 63 "MCBigoniMiniIH.mfront"
real thetaGm;
#line 64 "MCBigoniMiniIH.mfront"
real KFm;
#line 65 "MCBigoniMiniIH.mfront"
real KGm;
#line 66 "MCBigoniMiniIH.mfront"
stress aG;
#line 67 "MCBigoniMiniIH.mfront"
Stensor4 Ce;
#line 68 "MCBigoniMiniIH.mfront"
stress lambda;
#line 69 "MCBigoniMiniIH.mfront"
stress mu;
#line 70 "MCBigoniMiniIH.mfront"
stress ks;

real theta;
real epsilon;
real minimal_time_step_scaling_factor;
real maximal_time_step_scaling_factor;
real numerical_jacobian_epsilon;
ushort iterMax;

//! Tangent operator;
TangentOperator Dt;
//! alias to the tangent operator;
TangentOperator& dsig_ddeto;
// updating material properties, in mandatory
void updateMaterialPropertiesDependantOnStateVariables(){
using namespace std;
using namespace tfel::math;
using std::vector;
}

// Jacobian
tfel::math::tmatrix<2+StensorSize,2+StensorSize,real> jacobian;
// zeros
tfel::math::tvector<2+StensorSize,real> zeros;

// previous zeros
tfel::math::tvector<2+StensorSize,real> zeros_1;

// function
tfel::math::tvector<2+StensorSize,real> fzeros;

// number of iterations
unsigned int iter = 0u;

void computeNumericalJacobian(tfel::math::tmatrix<2+StensorSize,2+StensorSize,real>& njacobian)
{
using namespace std;
using namespace tfel::math;
tvector<2+StensorSize,real> tzeros(this->zeros);
tvector<2+StensorSize,real> tfzeros(this->fzeros);
tmatrix<2+StensorSize,2+StensorSize,real> tjacobian(this->jacobian);
for(unsigned short idx = 0; idx!= 2+StensorSize;++idx){
this->zeros(idx) -= this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->zeros = tzeros;
tvector<2+StensorSize,real> tfzeros2(this->fzeros);
this->zeros(idx) += this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->fzeros = (this->fzeros-tfzeros2)/(2*(this->numerical_jacobian_epsilon));
for(unsigned short idx2 = 0; idx2!= 2+StensorSize;++idx2){
njacobian(idx2,idx) = this->fzeros(idx2);
}
this->zeros    = tzeros;
this->fzeros   = tfzeros;
}
if(&njacobian!=&(this->jacobian)){
this->jacobian = tjacobian;
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_lam)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_lam(idx)=vect_e(StensorSize);
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<2+StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_lam,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_gap)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<2+StensorSize,real> vect_e(real(0));
vect_e(idx) = real(1);
TinyMatrixSolve<2+StensorSize,real>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_lam(idx)=vect_e(StensorSize);
partial_jacobian_gap(idx)=vect_e(1+StensorSize);
}
}

void additionalConvergenceChecks(bool&,real&,const SMType) const{
} // end of additionalConvergenceChecks

void computeThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 154 "MCBigoniMiniIH.mfront"
this->sig=this->lambda*trace((this->eel+(this->theta)*(this->deel)))*StrainStensor::Id()+2.*this->mu*(this->eel+(this->theta)*(this->deel));
} // end of MCBigoniMiniIH::computeThermodynamicForces

void computeFinalThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 154 "MCBigoniMiniIH.mfront"
this->sig=this->lambda*trace(this->eel)*StrainStensor::Id()+2.*this->mu*this->eel;
} // end of MCBigoniMiniIH::computeFinalThermodynamicForces

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->eel += this->deel;
this->lam += this->dlam;
this->gap += this->dgap;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables(){
using namespace std;
using namespace tfel::math;
#line 234 "MCBigoniMiniIH.mfront"
this->inst+=this->dt;
#line 235 "MCBigoniMiniIH.mfront"
this->niter=iter;
#line 236 "MCBigoniMiniIH.mfront"
if (this->dlam>0) {
#line 237 "MCBigoniMiniIH.mfront"
this->ip=1;
#line 238 "MCBigoniMiniIH.mfront"
this->evp+=this->dlam*sin(this->psir);
#line 239 "MCBigoniMiniIH.mfront"
} else {
#line 240 "MCBigoniMiniIH.mfront"
this->ip=0;
#line 241 "MCBigoniMiniIH.mfront"
}
}

//! \brief Default constructor (disabled)
MCBigoniMiniIH() =delete ;
//! \brief Copy constructor (disabled)
MCBigoniMiniIH(const MCBigoniMiniIH&) = delete;
//! \brief Assignement operator (disabled)
MCBigoniMiniIH& operator = (const MCBigoniMiniIH&) = delete;

public:

/*!
* \brief Constructor
*/
MCBigoniMiniIH(const MCBigoniMiniIHBehaviourData<hypothesis,Type,false>& src1,
const MCBigoniMiniIHIntegrationData<hypothesis,Type,false>& src2)
: MCBigoniMiniIHBehaviourData<hypothesis,Type,false>(src1),
MCBigoniMiniIHIntegrationData<hypothesis,Type,false>(src2),
deel(this->zeros),
dlam(this->zeros(StensorSize)),
dgap(this->zeros(1+StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->theta = MCBigoniMiniIHParametersInitializer::get().theta;
this->epsilon = MCBigoniMiniIHParametersInitializer::get().epsilon;
this->minimal_time_step_scaling_factor = MCBigoniMiniIHParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = MCBigoniMiniIHParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = MCBigoniMiniIHParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = MCBigoniMiniIHParametersInitializer::get().iterMax;
}

/*
 * \brief constructor for the Aster interface
 * \param[in] ASTERdt_: time increment
 * \param[in] ASTERT_: temperature
 * \param[in] ASTERdT_: temperature increment
 * \param[in] ASTERmat: material properties
 * \param[in] ASTERint_vars: state variables
 * \param[in] ASTERext_vars: external state variables
 * \param[in] ASTERdext_vars: external state variables increments
 */
MCBigoniMiniIH(const Type* const ASTERdt_,
const Type* const ASTERT_,
const Type* const ASTERdT_,
const Type* const ASTERmat,
const Type* const ASTERint_vars,
const Type* const ASTERext_vars,
const Type* const ASTERdext_vars)
: MCBigoniMiniIHBehaviourData<hypothesis,Type,false>(ASTERT_,ASTERmat,
ASTERint_vars,ASTERext_vars),
MCBigoniMiniIHIntegrationData<hypothesis,Type,false>(ASTERdt_,ASTERdT_,ASTERdext_vars),
deel(this->zeros),
dlam(this->zeros(StensorSize)),
dgap(this->zeros(1+StensorSize)),
dsig_ddeto(Dt),
zeros(real(0)),
fzeros(real(0))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->theta = MCBigoniMiniIHParametersInitializer::get().theta;
this->epsilon = MCBigoniMiniIHParametersInitializer::get().epsilon;
this->minimal_time_step_scaling_factor = MCBigoniMiniIHParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = MCBigoniMiniIHParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = MCBigoniMiniIHParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = MCBigoniMiniIHParametersInitializer::get().iterMax;
}

/*!
 * \ brief initialize the behaviour with user code
 */
void initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 104 "MCBigoniMiniIH.mfront"
using namespace tfel::material::lame;
#line 105 "MCBigoniMiniIH.mfront"
this->local_zero_tolerance=real(1e-12);
#line 107 "MCBigoniMiniIH.mfront"
this->pi=4.*atan(1.);
#line 108 "MCBigoniMiniIH.mfront"
this->phir=this->phi*this->pi/180.;
#line 109 "MCBigoniMiniIH.mfront"
this->psir=this->psi*this->pi/180.;
#line 111 "MCBigoniMiniIH.mfront"
this->thetaFm=atan(-sin(this->phir)/sqrt(3.));
#line 112 "MCBigoniMiniIH.mfront"
this->thetaGm=atan(-sin(this->psir)/sqrt(3.));
#line 113 "MCBigoniMiniIH.mfront"
this->KFm=(cos(this->thetaFm)-sin(this->phir)*sin(this->thetaFm)/sqrt(3.));
#line 114 "MCBigoniMiniIH.mfront"
this->KGm=(cos(this->thetaGm)-sin(this->psir)*sin(this->thetaGm)/sqrt(3.));
#line 116 "MCBigoniMiniIH.mfront"
this->aG=this->at*tan(this->phir)/tan(this->psir);
#line 118 "MCBigoniMiniIH.mfront"
this->lambda=computeLambda(this->young,this->nu);
#line 119 "MCBigoniMiniIH.mfront"
this->mu=computeMu(this->young,this->nu);
#line 120 "MCBigoniMiniIH.mfront"
this->ks=this->lambda+2.*this->mu/3.;
#line 121 "MCBigoniMiniIH.mfront"
this->Ce=3.*this->ks*Stensor4::J()+2.*this->mu*Stensor4::K();
#line 123 "MCBigoniMiniIH.mfront"
if (this->inst==real(0) && this->lam==real(0)) {
#line 124 "MCBigoniMiniIH.mfront"
const Stensor4 Se=invert(this->Ce);
#line 125 "MCBigoniMiniIH.mfront"
this->eel=(Se*this->sig);
#line 126 "MCBigoniMiniIH.mfront"
}
}

/*!
* \brief set the policy for "out of bounds" conditions
*/
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

/*!
* \brief check bounds
*/
void checkBounds() const{
} // end of checkBounds

IntegrationResult computePredictionOperator(const SMFlag,const SMType) override{
tfel::raise("MCBigoniMiniIH::computePredictionOperator: "
"unsupported prediction operator flag");
}

real getMinimalTimeStepScalingFactor() const override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool,real>
computeAPrioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
 * \brief Integrate behaviour law over the time step
 */
IntegrationResult integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::STANDARDTANGENTOPERATOR,
"invalid tangent operator flag");
#line 136 "MCBigoniMiniIH.mfront"
StressStensor sigel(this->lambda*trace(this->eel+this->deto)*Stensor::Id()+2.*this->mu*(this->eel+this->deto));
#line 139 "MCBigoniMiniIH.mfront"
const StressStensor sdel=deviator(sigel);
#line 140 "MCBigoniMiniIH.mfront"
const stress J2el=.5*(sdel|sdel);
#line 141 "MCBigoniMiniIH.mfront"
const stress I1el=trace(sigel);
#line 144 "MCBigoniMiniIH.mfront"
const stress RFel=sqrt(J2el*this->KFm*this->KFm+this->at*this->at*sin(this->phir)*sin(this->phir));
#line 145 "MCBigoniMiniIH.mfront"
this->b=RFel+I1el*sin(this->phir)/3.-this->coh*(1.+this->hc*this->gap)*cos(this->phir)>real(0);
auto error = real{};
bool converged=false;
this->iter=0;
while((converged==false)&&
(this->iter<MCBigoniMiniIH::iterMax)){
++(this->iter);
this->computeThermodynamicForces();
const auto computeFdF_ok = this->computeFdF(false);
if(computeFdF_ok){
error=norm(this->fzeros)/(real(2+StensorSize));
}
if((!computeFdF_ok)||(!ieee754::isfinite(error))){
if(this->iter==1){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
} else {
const real integrate_one_half = real(1)/real(2);
this->zeros -= (this->zeros-this->zeros_1)*integrate_one_half;
this->updateMaterialPropertiesDependantOnStateVariables();
}
} else {
this->zeros_1  = this->zeros;
converged = error<this->epsilon;
this->additionalConvergenceChecks(converged, error, smt);
if((!converged)||(smt!=NOSTIFFNESSREQUESTED)){
}
if(!converged){
try{
TinyMatrixSolve<2+StensorSize,real>::exe(this->jacobian,this->fzeros);
}
catch(LUException&){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->zeros -= this->fzeros;
this->updateMaterialPropertiesDependantOnStateVariables();
}
}
}
if(this->iter==this->iterMax){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
this->updateIntegrationVariables();
this->updateStateVariables();
this->computeFinalThermodynamicForces();
this->updateAuxiliaryStateVariables();
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis,Type,false>::SUCCESS;
} // end of MCBigoniMiniIH::integrate

/*!
* \brief compute fzeros and jacobian
*/
bool computeFdF(const bool perturbatedSystemEvaluation){
using namespace std;
using namespace tfel::math;
using std::vector;
// silent compiler warning
static_cast<void>(perturbatedSystemEvaluation); 
constexpr const auto eel_offset = 0;
static_cast<void>(eel_offset);
typename tfel::math::StensorFromTinyVectorView<N,2+StensorSize,0,real>::type feel(this->fzeros);
constexpr const auto lam_offset = StensorSize;
static_cast<void>(lam_offset);
real& flam(this->fzeros(StensorSize));
constexpr const auto gap_offset = 1+StensorSize;
static_cast<void>(gap_offset);
real& fgap(this->fzeros(1+StensorSize));
// derivative of variable feel by variable eel
typename tfel::math::ST2toST2FromTinyMatrixView<N,2+StensorSize,2+StensorSize,
0,0,real>::type dfeel_ddeel(this->jacobian);
// derivative of variable feel by variable lam
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+StensorSize,2+StensorSize,
0,StensorSize,real>::type dfeel_ddlam(this->jacobian);
// derivative of variable feel by variable gap
typename tfel::math::StensorFromTinyMatrixColumnView<N,2+StensorSize,2+StensorSize,
0,1+StensorSize,real>::type dfeel_ddgap(this->jacobian);
// derivative of variable flam by variable eel
typename tfel::math::StensorFromTinyMatrixRowView<N,2+StensorSize,2+StensorSize,
StensorSize,0,real>::type dflam_ddeel(this->jacobian);
// derivative of variable flam by variable lam
real& dflam_ddlam = this->jacobian(StensorSize,StensorSize);
// derivative of variable flam by variable gap
real& dflam_ddgap = this->jacobian(StensorSize,1+StensorSize);
// derivative of variable fgap by variable eel
typename tfel::math::StensorFromTinyMatrixRowView<N,2+StensorSize,2+StensorSize,
1+StensorSize,0,real>::type dfgap_ddeel(this->jacobian);
// derivative of variable fgap by variable lam
real& dfgap_ddlam = this->jacobian(1+StensorSize,StensorSize);
// derivative of variable fgap by variable gap
real& dfgap_ddgap = this->jacobian(1+StensorSize,1+StensorSize);
// setting jacobian to identity
std::fill(this->jacobian.begin(),this->jacobian.end(),real(0));
for(unsigned short idx = 0; idx!=2+StensorSize;++idx){
this->jacobian(idx,idx)= real(1);
}
// setting f values to zeros
this->fzeros = this->zeros;
#line 164 "MCBigoniMiniIH.mfront"
if ((this->b)){
#line 167 "MCBigoniMiniIH.mfront"
const StressStensor sd=deviator((this->sig));
#line 168 "MCBigoniMiniIH.mfront"
const stress J2=.5*(sd|sd);
#line 169 "MCBigoniMiniIH.mfront"
const stress I1=trace((this->sig));
#line 172 "MCBigoniMiniIH.mfront"
const stress RF=sqrt(J2*(this->KFm)*(this->KFm)+(this->at)*(this->at)*sin((this->phir))*sin((this->phir)));
#line 173 "MCBigoniMiniIH.mfront"
const stress RG=sqrt(J2*(this->KGm)*(this->KGm)+(this->aG)*(this->aG)*sin((this->psir))*sin((this->psir)));
#line 174 "MCBigoniMiniIH.mfront"
const stress F=RF+I1*sin((this->phir))/3.-(this->coh)*(1.+(this->hc)*((this->gap)+(this->dgap)))*cos((this->phir));
#line 177 "MCBigoniMiniIH.mfront"
const real dG_dI1=sin((this->psir))/3.;
#line 178 "MCBigoniMiniIH.mfront"
const real dG_dJ2=.5*(this->KGm)*(this->KGm)/max(RG,(this->local_zero_tolerance));
#line 179 "MCBigoniMiniIH.mfront"
const Stensor nG=dG_dI1*Stensor::Id()+dG_dJ2*sd;
#line 182 "MCBigoniMiniIH.mfront"
feel=(this->deel)-(this->deto)+(this->dlam)*nG;
#line 183 "MCBigoniMiniIH.mfront"
flam=F/(this->young);
#line 184 "MCBigoniMiniIH.mfront"
fgap=(this->dgap)-(this->dlam)*sqrt(2.*deviator(nG)|deviator(nG)/3.);
#line 192 "MCBigoniMiniIH.mfront"
const real dG_ddJ2=-.5*(this->KGm)*(this->KGm)*dG_dJ2/max(RG,(this->local_zero_tolerance))/max(RG,(this->local_zero_tolerance));
#line 193 "MCBigoniMiniIH.mfront"
const Stensor4 dnG_dsig=dG_ddJ2*(sd^sd)+dG_dJ2*Stensor4::K();
#line 195 "MCBigoniMiniIH.mfront"
const real dF_dI1=sin((this->phir))/3.;
#line 196 "MCBigoniMiniIH.mfront"
const real dF_dJ2=.5*(this->KFm)*(this->KFm)/max(RF,(this->local_zero_tolerance));
#line 197 "MCBigoniMiniIH.mfront"
const Stensor dF_dsig=dF_dI1*Stensor::Id()+dF_dJ2*sd;
#line 199 "MCBigoniMiniIH.mfront"
const real dF_ddgap=-(this->coh)*(this->hc)*cos((this->phir));
#line 202 "MCBigoniMiniIH.mfront"
dfeel_ddeel=Stensor4::Id()+(this->dlam)*(dnG_dsig*(this->Ce));
#line 203 "MCBigoniMiniIH.mfront"
dfeel_ddlam=nG;
#line 204 "MCBigoniMiniIH.mfront"
dfeel_ddgap=Stensor(real(0));
#line 207 "MCBigoniMiniIH.mfront"
dflam_ddeel=(dF_dsig|(this->Ce))/(this->young);
#line 208 "MCBigoniMiniIH.mfront"
dflam_ddlam=real(0);
#line 209 "MCBigoniMiniIH.mfront"
dflam_ddgap=dF_ddgap/(this->young);
#line 212 "MCBigoniMiniIH.mfront"
dfgap_ddeel=-(this->dlam)*sqrt(2./3.)*((deviator(nG)|dnG_dsig)|(this->Ce));
#line 213 "MCBigoniMiniIH.mfront"
dfgap_ddlam=-sqrt(2.*deviator(nG)|deviator(nG)/3.);
#line 214 "MCBigoniMiniIH.mfront"
dfgap_ddgap=real(1);
#line 218 "MCBigoniMiniIH.mfront"
}
#line 221 "MCBigoniMiniIH.mfront"
else {
#line 223 "MCBigoniMiniIH.mfront"
feel=(this->deel)-(this->deto);
#line 224 "MCBigoniMiniIH.mfront"
flam=(this->dlam);
#line 226 "MCBigoniMiniIH.mfront"
}
static_cast<void>(dfeel_ddeel); /* suppress potential warnings */
static_cast<void>(dfeel_ddlam); /* suppress potential warnings */
static_cast<void>(dfeel_ddgap); /* suppress potential warnings */
static_cast<void>(dflam_ddeel); /* suppress potential warnings */
static_cast<void>(dflam_ddlam); /* suppress potential warnings */
static_cast<void>(dflam_ddgap); /* suppress potential warnings */
static_cast<void>(dfgap_ddeel); /* suppress potential warnings */
static_cast<void>(dfgap_ddlam); /* suppress potential warnings */
static_cast<void>(dfgap_ddgap); /* suppress potential warnings */
return true;
}

std::pair<bool,real>
computeAPosterioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(real& Psi_s) const
{
Psi_s=0;
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(real& Psi_d) const
{
Psi_d=0;
}

bool computeConsistentTangentOperator(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
TinyPermutation<2+StensorSize> jacobian_permutation;
TinyMatrixSolve<2+StensorSize,real>::decomp(this->jacobian,jacobian_permutation);
struct TFEL_VISIBILITY_LOCAL GetPartialJacobianInvert{
GetPartialJacobianInvert(MCBigoniMiniIH& b,
const tfel::math::TinyPermutation<2+StensorSize>& p)
: behaviour(b),
permutation(p)
{}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_lam){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_lam);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_lam,
tfel::math::derivative_type<strain, StrainStensor>& partial_jacobian_gap){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_lam,
partial_jacobian_gap);
}
private:
MCBigoniMiniIH& behaviour;
const tfel::math::TinyPermutation<2+StensorSize>& permutation;
}; // end of struct GetPartialJacobianInvert
GetPartialJacobianInvert getPartialJacobianInvert(*this, jacobian_permutation);
#line 250 "MCBigoniMiniIH.mfront"
if((smt==ELASTIC)||(smt==SECANTOPERATOR)) {
#line 251 "MCBigoniMiniIH.mfront"
computeElasticStiffness<N,Type>::exe((this->Dt),(this->lambda),(this->mu));
#line 252 "MCBigoniMiniIH.mfront"
}
#line 253 "MCBigoniMiniIH.mfront"
else if (smt==CONSISTENTTANGENTOPERATOR) {
#line 254 "MCBigoniMiniIH.mfront"
Stensor4 Je;
#line 255 "MCBigoniMiniIH.mfront"
getPartialJacobianInvert(Je);
#line 256 "MCBigoniMiniIH.mfront"
(this->Dt)=(this->Ce)*Je;
#line 257 "MCBigoniMiniIH.mfront"
}
#line 258 "MCBigoniMiniIH.mfront"
else {
#line 259 "MCBigoniMiniIH.mfront"
return false;
#line 260 "MCBigoniMiniIH.mfront"
}
return true;
}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->eto  += this->deto;
this->T += this->dT;
}

//!
~MCBigoniMiniIH()
 override = default;

private:

std::pair<bool,real> computeAPrioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

std::pair<bool,real> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = None;
}; // end of MCBigoniMiniIH class

template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
std::ostream&
operator <<(std::ostream& os,const MCBigoniMiniIH<hypothesis,Type,false>& b)
{
os << "εᵗᵒ : " << b.eto << '\n';
os << "Δεᵗᵒ : " << b.deto << '\n';
os << "σ : " << b.sig << '\n';
os << "Δt : " << b.dt << '\n';
os << "young : " << b.young << '\n';
os << "nu : " << b.nu << '\n';
os << "phi : " << b.phi << '\n';
os << "psi : " << b.psi << '\n';
os << "coh : " << b.coh << '\n';
os << "at : " << b.at << '\n';
os << "hc : " << b.hc << '\n';
os << "εᵉˡ : " << b.eel << '\n';
os << "Δεᵉˡ : " << b.deel << '\n';
os << "lam : " << b.lam << '\n';
os << "Δlam : " << b.dlam << '\n';
os << "gap : " << b.gap << '\n';
os << "Δgap : " << b.dgap << '\n';
os << "niter : " << b.niter << '\n';
os << "ip : " << b.ip << '\n';
os << "evp : " << b.evp << '\n';
os << "inst : " << b.inst << '\n';
os << "T : " << b.T << '\n';
os << "ΔT : " << b.dT << '\n';
os << "Ce : " << b.Ce << '\n';
os << "θ : " << b.theta << '\n';
os << "ε : " << b.epsilon << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "numerical_jacobian_epsilon : " << b.numerical_jacobian_epsilon << '\n';
os << "iterMax : " << b.iterMax << '\n';
return os;
}

/*!
* Partial specialisation for MCBigoniMiniIH.
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename Type>
class MechanicalBehaviourTraits<MCBigoniMiniIH<hypothesis,Type,false> >
{
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 7;
static constexpr unsigned short internal_variables_nb  = 6+StensorSize;
static constexpr unsigned short external_variables_nb  = 1;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "MCBigoniMiniIH";
}

};

/*!
* Partial specialisation for MCBigoniMiniIH.
*/
template<typename Type>
class MechanicalBehaviourTraits<MCBigoniMiniIH<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS,Type,false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 0;
static constexpr unsigned short external_variables_nb  = 0;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "MCBigoniMiniIH";
}

};

/*!
* Partial specialisation for MCBigoniMiniIH.
*/
template<typename Type>
class MechanicalBehaviourTraits<MCBigoniMiniIH<ModellingHypothesis::PLANESTRESS,Type,false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
typedef Type NumType;
static constexpr unsigned short material_properties_nb = 0;
static constexpr unsigned short internal_variables_nb  = 0;
static constexpr unsigned short external_variables_nb  = 0;
static constexpr unsigned short external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "MCBigoniMiniIH";
}

};

} // end of namespace material

} // end of namespace tfel

#endif /* LIB_TFELMATERIAL_MCBIGONIMINIIH_HXX */
