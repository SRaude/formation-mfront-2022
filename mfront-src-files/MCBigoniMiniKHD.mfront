// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Coupled plastic-damage model (non-associated plastic flow) model based on:
//    * http://tfel.sourceforge.net/MohrCoulomb.html
//    * https://doi.org/10.1016/j.compstruc.2016.11.010
//    * https://doi.org/10.1016/0045-7949(94)00339-5
//    * https://doi.org/10.1051/meca/2018043
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@DSL Implicit;
@Author Simon Raude;
@Date 15/09/2022;
@Behaviour PDM_KH_MC_NA;

@Algorithm NewtonRaphson;
// @Algorithm NewtonRaphson_NumericalJacobian;
// @CompareToNumericalJacobian true;
// @PerturbationValueForNumericalJacobianComputation 1.e-10;

@Theta 1.; 
@Epsilon 1.e-14;

// >>>>>>>>>>>>>>>>>>>>>
// 1. Material Constants
// <<<<<<<<<<<<<<<<<<<<<

// Young modulus (>0, Pa)
@MaterialProperty stress young;
young.setGlossaryName("YoungModulus");

// Poisson ratio (-1<..<0.5, -)
@MaterialProperty real nu;
nu.setGlossaryName("PoissonRatio");

// Friction angle (>0, °)
@MaterialProperty real phi;
phi.setEntryName("FrictionAngle");

// Dilation angle (>0, °)
@MaterialProperty real psi;
psi.setEntryName("DilationAngle");

// Cohesion (>0, Pa)
@MaterialProperty stress coh;
coh.setEntryName("Cohesion");

// Controls the intersection of the hyperbolic branch of the plastic criterion with the "Xm" axis (<0..<=1, -)
@MaterialProperty real at;
at.setEntryName("TensionCutOff");

// Damage Strength (>0, Pa)
@MaterialProperty stress Yc;
Yc.setEntryName("DamageStrength");

// Exponent of the denominator of the damage function (0<..<=1, -)
@MaterialProperty real nD;
nD.setEntryName("DExpoDamageFunc");

// Reducing factor in the expression of the kinematic tensor (>=1, -)
@MaterialProperty real qD;
qD.setEntryName("QDamageFactor");

// >>>>>>>>>>>>>>>>>>
// 2. Local Variables
// <<<<<<<<<<<<<<<<<<

@LocalVariable bool b[2];     // Boolean b[0] for plasticity condition, b[1] for damage condition
@LocalVariable real tol;      // Local zero tolerance
@LocalVariable stress stol;   // Local zero tolerance for stresses
@LocalVariable real pi;       // Real pi=3.14....
@LocalVariable real phir;     // Friction angle in radians
@LocalVariable real psir;     // Dilation angle in radians
@LocalVariable stress ptphi;  // Theoretical tension strength from the Mohr-Coulomb criterion (compression, not extension) = C/tan(phi)
@LocalVariable stress ptpsi;  // Theoretical tension strength from the Mohr-Coulomb criterion (applied in the plastic flow function) = C/tan(psi)
@LocalVariable real kphi;     // Friction coefficient in the Mohr-Coulomb criterion = 6*sin(phi)/(3-sin(phi))
@LocalVariable real kpsi;     // Friction coefficient in the plastic flow function = 6*sin(psi)/(3-sin(psi))
@LocalVariable real bK;       // Homogenisation factor for the bulk modulus in the expression of the tensor for the kinematical hardening
@LocalVariable real bMu;      // Homogenisation factor for the shear modulus in the expression of the tensor for the kinematical hardening
@LocalVariable real alpc;     // Critical value for the damage variable ~1 but <1
@LocalVariable real rD;       // Regularisation coefficient for the damage function fh
@LocalVariable Stensor4 Ce;   // Elastic stiffness tensor
@LocalVariable Stensor4 Ckin; // Reduced elastic stiffness tensor for the kinematical hardening
@LocalVariable stress lambda; // First Lame modulus
@LocalVariable stress mu;     // Shear modulus
@LocalVariable stress ks;     // Bulk modulus

// >>>>>>>>>>>>>>>>>
// 3. State Variable
// <<<<<<<<<<<<<<<<<

@StateVariable StrainStensor epl; // Plastic strain tensor
@StateVariable real lam;          // Plastic multiplier
@StateVariable real alp;          // Damage variable in [0,alpc]

epl.setGlossaryName("PlasticStrain");
lam.setEntryName("PlastMultiplier");
alp.setEntryName("DamageVariable");

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// 4. Auxilliary state variables
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@AuxiliaryStateVariable real niter;            // Number of Newton iterations
@AuxiliaryStateVariable real ip;               // Plastic index
@AuxiliaryStateVariable real domain;           // Domain
@AuxiliaryStateVariable stress XeqASV;         // Equivalent shear stress associated to plastic strain
@AuxiliaryStateVariable stress XmASV;          // Mean stress associated to plastic strain
@AuxiliaryStateVariable stress YASV;           // Damage stress

niter.setEntryName("LocalNewtonIter");
ip.setEntryName("PlasticIndex");
domain.setEntryName("PDDomain");
XeqASV.setEntryName("EquiPlastStress");
XmASV.setEntryName("MeanPlastStress");
YASV.setEntryName("DamageStress");

// >>>>>>>>>>>>>>>>>>>>>>>>
// 5. Init. local variables
// <<<<<<<<<<<<<<<<<<<<<<<<

@Includes{
	#include"TFEL/Material/Lame.hxx"
}

@InitLocalVariables{
	using namespace tfel::material::lame;
	tol=real(1e-12);
	stol=young*tol;
	pi=4.*atan(1.);
	phir=phi*pi/180.;
	psir=psi*pi/180.;
	kphi=6.*sin(phir)/(3.-sin(phir));
	kpsi=6.*sin(psir)/(3.-sin(psir));
	ptphi=coh/tan(phir);
	ptpsi=coh/tan(psir);
	bK=16./9.*(1.-nu*nu)/(1.-2.*nu);
	bMu=32./45.*(1.-nu)*(5.-nu)/(2.-nu);
	alpc=.995;
	rD=1.e-4;
	lambda=computeLambda(young,nu);
	mu=computeMu(young,nu);
	ks=lambda+2.*mu/3.;
	Ce=3.*ks*Stensor4::J()+2.*mu*Stensor4::K();
	Ckin=(3.*ks*Stensor4::J()/bK+2.*mu*Stensor4::K()/bMu)/qD;
}

// >>>>>>>>>>>>>>>>>>>>>
// 6. Elastic Prediction
// <<<<<<<<<<<<<<<<<<<<<

@Predictor{
	
	// >>> 6.1 Compute the elastic trial stress
	StressStensor sigel(lambda*trace(eel+deto)*Stensor::Id()+2.*mu*(eel+deto));
	
	// >>> 6.2 Compute the damage function and the tensor Hkin for the kinematical hardening
	const real fh=(1.-alp)*(1.-alp)/pow(alp+rD,nD);
	const Stensor4 Hkin=fh*Ckin;

	// >>> 6.3 Compute the thermo. force associated with the plastic strain
	const StressStensor Xel=sigel-(Hkin*epl);
	
	// >>> 6.4 Plastic MC criterion - condition for plasticity
	b[0]=sqrt(sigmaeq(Xel)*sigmaeq(Xel)+(kphi*at*ptphi)*(kphi*at*ptphi))+kphi*(trace(Xel)/3.-ptphi)>real(0);

}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>
// 7. Update the Stress Tensor
// <<<<<<<<<<<<<<<<<<<<<<<<<<<

@ComputeStress{
	sig=lambda*trace(eel)*StrainStensor::Id()+2.*mu*eel;
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>
// 8. Plastic-Damage correction
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<

@Integrator{

	// >>> 8.1 Integration when alp>=alpc - perfect plasticity
	if (b[0] && alp>=alpc){

		// >>>>>> 8.1.1 Compute the "kinematic tensor"
		const real fh=(1.-alpc)*(1.-alpc)/pow(alpc+rD,nD);
		const Stensor4 Hkin=fh*Ckin;

		// >>>>>> 8.1.2 Compute the thermo. force associated with the plastic strain
		const StressStensor X=sig-(Hkin*(epl+depl));
		
		// >>>>>> 8.1.3 Compute the plastic criterion and the plastic flow direction
		const stress Rp=sqrt(sigmaeq(X)*sigmaeq(X)+(kphi*at*ptphi)*(kphi*at*ptphi));  // For the plastic criterion
		const stress RpF=sqrt(sigmaeq(X)*sigmaeq(X)+(kpsi*at*ptpsi)*(kpsi*at*ptpsi)); // For the plastic flow function
		const stress Fp=Rp+kphi*(trace(X)/3.-ptphi);                                  // The plastic criterion
		const Stensor Np=1.5*deviator(X)/max(RpF,stol)+kpsi*Stensor::Id()/3.;         // The non-associated plastic flow direction

		// >>>>>> 8.1.4 Equations to be solved
		feel=deel-deto+dlam*Np;
		fepl=depl-dlam*Np;
		flam=Fp/young;
		falp=dalp;
		
		// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Comment this block if "@Algorithm NewtonRaphson_NumericalJacobian" >>>>>>>>>>>>>>>>
		
		// >>>>>> 8.1.5 Jacobian
		
		// >>>>>>>>> 8.1.5.1 Some tools
		// >>>>>>>>>>>> Compute dNp_dsig
		const Stensor4 dX_dsig=Stensor4::Id();
		const Stensor4 dNp_dX=(Stensor4::M()-(deviator(Np)^deviator(Np)))/max(RpF,stol);
		const Stensor4 dNp_dsig=(dNp_dX*dX_dsig);
		// >>>>>>>>>>>> Compute dNp_ddepl
		const Stensor4 dX_ddepl=-Hkin;
		const Stensor4 dNp_ddepl=(dNp_dX*dX_ddepl);
		// >>>>>>>>>>>> Compute dFp_dsig
		const Stensor dFp_dX=1.5*deviator(X)/max(Rp,stol)+kphi*Stensor::Id()/3.;
		const Stensor dFp_dsig=(dFp_dX|dX_dsig);
		// >>>>>>>>>>>> Compute dFp_ddepl
		const Stensor dFp_ddepl=(dFp_dX|dX_ddepl);
		
		// >>>>>>>>> 8.1.5.2 First line
		dfeel_ddeel=Stensor4::Id()+dlam*(dNp_dsig*Ce);
		dfeel_ddepl=dlam*dNp_ddepl;
		dfeel_ddlam=Np;
		dfeel_ddalp=Stensor(real(0));

		// >>>>>>>>> 8.1.5.3 Second line
		dfepl_ddeel=-dlam*(dNp_dsig*Ce);
		dfepl_ddepl=Stensor4::Id()-dlam*dNp_ddepl;
		dfepl_ddlam=-Np;
		dfepl_ddalp=Stensor(real(0));

		// >>>>>>>>> 8.1.5.4 Third line
		dflam_ddeel=(dFp_dsig|Ce)/young;
		dflam_ddepl=dFp_ddepl/young;
		dflam_ddlam=real(0);
		dflam_ddalp=real(0);
		
		// >>>>>>>>> 8.1.5.5 Last line
		dfalp_ddeel=Stensor(real(0));
		dfalp_ddepl=Stensor(real(0));
		dfalp_ddlam=real(0);
		dfalp_ddalp=real(1);
		
		// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
		
		
	}

	// >>> 8.2 Integration when b[0]=True and alp<alpc - test for the damage criterion
	if (b[0] && alp<alpc){

		// >>>>>> 8.2.1 Compute the "kinematic tensor" Hkin
		const real fh=(1.-alp)*(1.-alp)/pow(alp+rD,nD);
		const real dfh_dalp=(1.-alp)*(alp*nD-2.*alp-2.*rD-nD)/pow(alp+rD,nD+1.);
		const Stensor4 Hkin=fh*Ckin;
		const Stensor4 dHkin_dalp=dfh_dalp*Ckin;

		// >>>>>> 8.2.2 Compute the thermo. forces associated with the plastic strain and the damage variable
		const StressStensor X=sig-(Hkin*(epl+depl));
		const stress Y=-.5*((epl+depl)|dHkin_dalp)|(epl+depl);
		
		// >>>>>> 8.2.3 Compute the plastic criterion and the plastic flow direction
		const stress Rp=sqrt(sigmaeq(X)*sigmaeq(X)+(kphi*at*ptphi)*(kphi*at*ptphi));  // For the plastic criterion
		const stress RpF=sqrt(sigmaeq(X)*sigmaeq(X)+(kpsi*at*ptpsi)*(kpsi*at*ptpsi)); // For the plastic flow function
		const stress Fp=Rp+kphi*(trace(X)/3.-ptphi);                                  // The plastic criterion
		const Stensor Np=1.5*deviator(X)/max(RpF,stol)+kpsi*Stensor::Id()/3.;         // The non-associated plastic flow direction

		// >>>>>> 8.2.4 Compute the damage criterion
		b[1]=Y-Yc>real(0);

		// >>>>>> 8.2.5 Equations to be solved
		feel=deel-deto+dlam*Np;
		fepl=depl-dlam*Np;
		flam=Fp/young;
		falp=dalp;
		
		// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Comment this block if "@Algorithm NewtonRaphson_NumericalJacobian" >>>>>>>>>>>>>>>>
		
		// >>>>>> 8.2.6 Jacobian

		// >>>>>>>>> 8.2.6.1 Some tools
		// >>>>>>>>>>>> Compute dNp_dsig
		const Stensor4 dX_dsig=Stensor4::Id();
		const Stensor4 dNp_dX=(Stensor4::M()-(deviator(Np)^deviator(Np)))/max(RpF,stol);
		const Stensor4 dNp_dsig=(dNp_dX*dX_dsig);
		// >>>>>>>>>>>> Compute dNp_ddepl
		const Stensor4 dX_ddepl=-Hkin;
		const Stensor4 dNp_ddepl=(dNp_dX*dX_ddepl);
		// >>>>>>>>>>>> Compute dFp_dsig
		const Stensor dFp_dX=1.5*deviator(X)/max(Rp,stol)+kphi*Stensor::Id()/3.;
		const Stensor dFp_dsig=(dFp_dX|dX_dsig);
		// >>>>>>>>>>>> Compute dFp_ddepl
		const Stensor dFp_ddepl=(dFp_dX|dX_ddepl);
		
		// >>>>>>>>> 8.2.6.2 First line
		dfeel_ddeel=Stensor4::Id()+dlam*(dNp_dsig*Ce);
		dfeel_ddepl=dlam*dNp_ddepl;
		dfeel_ddlam=Np;
		dfeel_ddalp=Stensor(real(0));

		// >>>>>>>>> 8.2.6.3 Second line
		dfepl_ddeel=-dlam*(dNp_dsig*Ce);
		dfepl_ddepl=Stensor4::Id()-dlam*dNp_ddepl;
		dfepl_ddlam=-Np;
		dfepl_ddalp=Stensor(real(0));

		// >>>>>>>>> 8.2.6.4 Third line
		dflam_ddeel=(dFp_dsig|Ce)/young;
		dflam_ddepl=dFp_ddepl/young;
		dflam_ddlam=real(0);
		dflam_ddalp=real(0);
		
		// >>>>>>>>> 8.2.6.5 Last line
		dfalp_ddeel=Stensor(real(0));
		dfalp_ddepl=Stensor(real(0));
		dfalp_ddlam=real(0);
		dfalp_ddalp=real(1);
		
		// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
		
	}

	// >>> 8.3 Integration when b[0]=True, b[1]=True, and alp<alpc
	if (b[0] && b[1] && alp<alpc){

		// >>>>>> 8.3.1 Compute the "kinematic tensor" Hkin
		const real fh=(1.-alp-dalp)*(1.-alp-dalp)/pow(alp+dalp+rD,nD);
		const real dfh_dalp=(1.-alp-dalp)*((alp+dalp)*nD-2.*(alp+dalp)-2.*rD-nD)/pow(alp+dalp+rD,nD+1.);
		const Stensor4 Hkin=fh*Ckin;
		const Stensor4 dHkin_dalp=dfh_dalp*Ckin;

		// >>>>>> 8.3.2 Compute the thermo. forces associated with the plastic strain and the damage variable
		const StressStensor X=sig-(Hkin*(epl+depl));
		const stress Y=-.5*((epl+depl)|dHkin_dalp)|(epl+depl);
		
		// >>>>>> 8.3.3 Compute the plastic criterion, Fp, and the plastic flow direction, Np
		const stress Rp=sqrt(sigmaeq(X)*sigmaeq(X)+(kphi*at*ptphi)*(kphi*at*ptphi));
		const stress Fp=Rp+kphi*(trace(X)/3.-ptphi);
		const stress RpF=sqrt(sigmaeq(X)*sigmaeq(X)+(kpsi*at*ptpsi)*(kpsi*at*ptpsi));
		const Stensor Np=1.5*deviator(X)/max(RpF,stol)+kpsi*Stensor::Id()/3.; // Non-associated plastic flow

		// >>>>>> 8.3.4 Compute the damage criterion
		const stress Fd=Y-Yc;
		
		// >>>>>> 8.3.5 Equations to be solved
		feel=deel-deto+dlam*Np;
		fepl=depl-dlam*Np;
		flam=Fp/young;
		falp=Fd/young;

		// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Comment this block if "@Algorithm NewtonRaphson_NumericalJacobian" >>>>>>>>>>>>>>>>
		
		// >>>>>> 8.3.6 Jacobian

		// >>>>>>>>> 8.3.6.1 Some tools
		// >>>>>>>>>>>> Compute dNp_dsig
		const Stensor4 dX_dsig=Stensor4::Id();
		const Stensor4 dNp_dX=(Stensor4::M()-(deviator(Np)^deviator(Np)))/max(RpF,stol);
		const Stensor4 dNp_dsig=(dNp_dX*dX_dsig);
		// >>>>>>>>>>>> Compute dNp_ddepl
		const Stensor4 dX_ddepl=-Hkin;
		const Stensor4 dNp_ddepl=(dNp_dX*dX_ddepl);
		// >>>>>>>>>>>> Compute dNp_ddalp
		const Stensor4 dHkin_ddalp=dHkin_dalp;
		const StressStensor dX_ddalp=-(dHkin_ddalp*(epl+depl));
		const Stensor dNp_ddalp=(dNp_dX*dX_ddalp);
		// >>>>>>>>>>>> Compute dFp_dsig
		const Stensor dFp_dX=1.5*deviator(X)/max(Rp,stol)+kphi*Stensor::Id()/3.;
		const Stensor dFp_dsig=(dFp_dX|dX_dsig);
		// >>>>>>>>>>>> Compute dFp_ddepl
		const Stensor dFp_ddepl=(dFp_dX|dX_ddepl);
		// >>>>>>>>>>>> Compute dFp_ddalp
		const real dFp_ddalp=(dFp_dX|dX_ddalp);
		// >>>>>>>>>>>> Compute dFd_dY
		const real dFd_dY=real(1);
		// >>>>>>>>>>>> Compute dY_ddepl
		const Stensor dY_ddepl=-(dHkin_dalp*(epl+depl));
		// >>>>>>>>>>>> Compute dY_ddalp
		const real d2fh_ddalp_dalp=((alp+dalp)*(alp+dalp)*(nD*(nD-3.)+2.)+2.*(alp+dalp)*(-2.*rD*(nD-1.)-nD*(nD-1.))+2.*rD*(rD+2.*nD)+nD*(nD+1.))/pow(alp+dalp+rD,nD+2.);
		const Stensor4 d2Hkin_ddalp_dalp=d2fh_ddalp_dalp*Ckin;
		const stress dY_ddalp=-.5*((epl+depl)|d2Hkin_ddalp_dalp)|(epl+depl);
		
		// >>>>>>>>> 8.3.6.2 First line
		dfeel_ddeel=Stensor4::Id()+dlam*(dNp_dsig*Ce);
		dfeel_ddepl=dlam*dNp_ddepl;
		dfeel_ddlam=Np;
		dfeel_ddalp=dlam*dNp_ddalp;

		// >>>>>>>>> 8.3.6.3 Second line
		dfepl_ddeel=-dlam*(dNp_dsig*Ce);
		dfepl_ddepl=Stensor4::Id()-dlam*dNp_ddepl;
		dfepl_ddlam=-Np;
		dfepl_ddalp=-dlam*dNp_ddalp;

		// >>>>>>>>> 8.3.6.4 Third line
		dflam_ddeel=(dFp_dsig|Ce)/young;
		dflam_ddepl=dFp_ddepl/young;
		dflam_ddlam=real(0);
		dflam_ddalp=dFp_ddalp/young;
		
		// >>>>>>>>> 8.3.6.5 Last line
		dfalp_ddeel=Stensor(real(0));
		dfalp_ddepl=(dFd_dY*dY_ddepl)/young;
		dfalp_ddlam=real(0);
		dfalp_ddalp=(dFd_dY*dY_ddalp)/young;
		
		// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
		
	}

	// >>> 8.3 Elasticity
	if (not b[0]){

		feel=deel-deto;
		fepl=depl;
		flam=dlam;
		falp=dalp;

	}
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// 9. Update Auxilliary State Variables
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

@UpdateAuxiliaryStateVariables{
	const real fh=(1.-alp)*(1.-alp)/pow(alp+rD,nD);
	const real dfh_dalp=(1.-alp)*(alp*nD-2.*alp-2.*rD-nD)/pow(alp+rD,nD+1.);
	const Stensor4 Hkin=fh*Ckin;
	const Stensor4 dHkin_dalp=dfh_dalp*Ckin;
	const StressStensor XASV=sig-(Hkin*(epl));
	XeqASV=sigmaeq(XASV);
	XmASV=trace(XASV)/3.;
	YASV=-.5*((epl|dHkin_dalp)|epl);
	niter=iter;
	if (dlam>0) {
		ip=1;
	} else {
		ip=0;
	}
	if (b[0] && alp>=alpc) {
		domain=3;
	} else if (b[0] && alp<alpc) {
		domain=1;
	} else if (b[0] && b[1] && alp<alpc) {
		domain=2;
	} else {
		domain=0;
	}

}

// >>>>>>>>>>>>>>>>>>>>
// 10. Tangent Operator
// <<<<<<<<<<<<<<<<<<<<

@TangentOperator{
	if((smt==ELASTIC)||(smt==SECANTOPERATOR)) {
		computeElasticStiffness<N,Type>::exe(Dt,lambda,mu);
	}
	else if (smt==CONSISTENTTANGENTOPERATOR) {
		Stensor4 Je;
		getPartialJacobianInvert(Je);
		Dt=Ce*Je;
	} 
	else {
		return false;
	}
}
